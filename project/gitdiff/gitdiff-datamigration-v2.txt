diff --git a/api/models.py b/api/models.py
index 0a9e908..58765ef 100644
--- a/api/models.py
+++ b/api/models.py
@@ -1,5 +1,7 @@
 from pydantic import BaseModel
-from typing import List
+from typing import List, Optional
+from datetime import datetime
+from uuid import UUID
 
 class ConversionInput(BaseModel):
     sql: str
@@ -59,3 +61,27 @@ class SqlExecutionJob(BaseModel):
     submitted_at: str
     processed_at: str | None = None
     statement_results: list[dict] | None = None
+
+class DataMigrationJob(BaseModel):
+    job_id: UUID
+    source_db_type: str
+    source_connection_string: str
+    source_table_name: str
+    target_db_type: str
+    target_connection_string: str
+    target_table_name: str
+    status: str
+    started_at: datetime
+    completed_at: Optional[datetime] = None
+    total_rows: int = 0
+    migrated_rows: int = 0
+    failed_rows: int = 0
+    error_details: Optional[str] = None
+
+class DataMigrationRow(BaseModel):
+    row_id: UUID
+    job_id: UUID
+    source_primary_key_value: Optional[str] = None
+    status: str
+    error_message: Optional[str] = None
+    migrated_at: datetime
diff --git a/api/oracle_helper.py b/api/oracle_helper.py
index 274835f..b344eab 100644
--- a/api/oracle_helper.py
+++ b/api/oracle_helper.py
@@ -1,9 +1,32 @@
 import logging
 import oracledb
 from . import models
+from contextlib import contextmanager
 
 logging.basicConfig(level=logging.INFO)
 
+@contextmanager
+def get_oracle_connection(user, password, host, port, service_name=None, sid=None):
+    """Establishes a connection to the Oracle database and yields it.
+    Handles both service_name and sid for DSN creation.
+    """
+    if sid:
+        dsn = oracledb.makedsn(host, port, sid=sid)
+    elif service_name:
+        dsn = oracledb.makedsn(host, port, service_name=service_name)
+    else:
+        raise RuntimeError("Either a Service Name or SID must be provided.")
+    
+    connection = None
+    try:
+        connection = oracledb.connect(user=user, password=password, dsn=dsn)
+        yield connection
+    except oracledb.Error as e:
+        raise RuntimeError(f"Error connecting to Oracle: {e}") from e
+    finally:
+        if connection:
+            connection.close()
+
 def get_oracle_schemas(details: models.OracleConnectionDetails) -> list[str]:
     """Connects to an Oracle database and returns a list of schemas.
 
@@ -13,20 +36,14 @@ def get_oracle_schemas(details: models.OracleConnectionDetails) -> list[str]:
     Returns:
         A list of schema names.
     """
-    if details.sid:
-        dsn = oracledb.makedsn(details.host, details.port, sid=details.sid)
-    elif details.service_name:
-        dsn = oracledb.makedsn(details.host, details.port, service_name=details.service_name)
-    else:
-        raise RuntimeError("Either a Service Name or SID must be provided.")
     try:
-        with oracledb.connect(user=details.user, password=details.password, dsn=dsn) as connection:
+        with get_oracle_connection(details.user, details.password, details.host, details.port, details.service_name, details.sid) as connection:
             cursor = connection.cursor()
             cursor.execute("SELECT username FROM dba_users ORDER BY username")
             schemas = [row[0] for row in cursor]
             return schemas
     except oracledb.Error as e:
-        raise RuntimeError(f"Error connecting to Oracle or fetching schemas: {e}") from e
+        raise RuntimeError(f"Error fetching schemas: {e}") from e
 
 def list_oracle_objects(details: models.OracleConnectionDetails, schema_name: str, object_type: str) -> list[str]:
     """Connects to an Oracle database and lists objects for a given schema and object type.
@@ -39,15 +56,8 @@ def list_oracle_objects(details: models.OracleConnectionDetails, schema_name: st
     Returns:
         A list of object names.
     """
-    if details.sid:
-        dsn = oracledb.makedsn(details.host, details.port, sid=details.sid)
-    elif details.service_name:
-        dsn = oracledb.makedsn(details.host, details.port, service_name=details.service_name)
-    else:
-        raise RuntimeError("Either a Service Name or SID must be provided.")
-
     try:
-        with oracledb.connect(user=details.user, password=details.password, dsn=dsn) as connection:
+        with get_oracle_connection(details.user, details.password, details.host, details.port, details.service_name, details.sid) as connection:
             cursor = connection.cursor()
             cursor.execute("""
                 SELECT object_name
@@ -62,7 +72,7 @@ def list_oracle_objects(details: models.OracleConnectionDetails, schema_name: st
             objects = [row[0] for row in cursor]
             return objects
     except oracledb.Error as e:
-        raise RuntimeError(f"Error connecting to Oracle or fetching objects: {e}") from e
+        raise RuntimeError(f"Error fetching objects: {e}") from e
 
 def get_oracle_ddl(details: models.OracleConnectionDetails, schemas: list[str], object_types: list[str], object_names: list[str] | None = None, select_all: bool = False):
     """Connects to an Oracle database and extracts DDLs for specified schemas and object types.
@@ -77,17 +87,11 @@ def get_oracle_ddl(details: models.OracleConnectionDetails, schemas: list[str],
         A dictionary containing the DDLs.
     """
     logging.info(f"Starting DDL extraction for schemas: {schemas}, object types: {object_types}")
-    if details.sid:
-        dsn = oracledb.makedsn(details.host, details.port, sid=details.sid)
-    elif details.service_name:
-        dsn = oracledb.makedsn(details.host, details.port, service_name=details.service_name)
-    else:
-        raise RuntimeError("Either a Service Name or SID must be provided.")
 
     ddls = {obj_type: {} for obj_type in ['TABLE', 'VIEW', 'PROCEDURE', 'FUNCTION', 'INDEX', 'PACKAGE', 'TRIGGER']}
     ddls["db_name"] = ""
     try:
-        with oracledb.connect(user=details.user, password=details.password, dsn=dsn) as connection:
+        with get_oracle_connection(details.user, details.password, details.host, details.port, details.service_name, details.sid) as connection:
             logging.info(f"Successfully connected to Oracle database")
             cursor = connection.cursor()
             
@@ -153,8 +157,8 @@ def get_oracle_ddl(details: models.OracleConnectionDetails, schemas: list[str],
                             logging.error(f"Error fetching DDL for {obj_type} '{obj_name}': {error_obj.message}")
         return ddls
     except oracledb.Error as e:
-        logging.error(f"Error connecting to Oracle or fetching DDL: {e}")
-        raise RuntimeError(f"Error connecting to Oracle or fetching DDL: {e}") from e
+        logging.error(f"Error fetching DDL: {e}")
+        raise RuntimeError(f"Error fetching DDL: {e}") from e
 
 def test_oracle_ddl_extraction(details: models.OracleConnectionDetails):
     """
@@ -166,15 +170,8 @@ def test_oracle_ddl_extraction(details: models.OracleConnectionDetails):
     Returns:
         A success message if the extraction is successful, otherwise raises a RuntimeError.
     """
-    if details.sid:
-        dsn = oracledb.makedsn(details.host, details.port, sid=details.sid)
-    elif details.service_name:
-        dsn = oracledb.makedsn(details.host, details.port, service_name=details.service_name)
-    else:
-        raise RuntimeError("Either a Service Name or SID must be provided.")
-
     try:
-        with oracledb.connect(user=details.user, password=details.password, dsn=dsn) as connection:
+        with get_oracle_connection(details.user, details.password, details.host, details.port, details.service_name, details.sid) as connection:
             cursor = connection.cursor()
 
             # Configure DBMS_METADATA for cleaner DDL output
diff --git a/api/queues.py b/api/queues.py
index 19c8f30..65ec035 100644
--- a/api/queues.py
+++ b/api/queues.py
@@ -16,6 +16,12 @@ QUEUE_CONFIG['SQL_EXECUTION'] = {
     'dlq': 'sql_execution_dlq',
 }
 
+QUEUE_CONFIG['DATA_MIGRATION_ROW'] = {
+    'queue': 'data_migration_row_jobs',
+    'dlx': 'data_migration_row_dlx',
+    'dlq': 'data_migration_row_dlq',
+}
+
 def get_rabbitmq_connection():
     try:
         connection = pika.BlockingConnection(
@@ -24,4 +30,17 @@ def get_rabbitmq_connection():
         return connection
     except pika.exceptions.AMQPConnectionError as e:
         print(f"Failed to connect to RabbitMQ: {e}")
-        return None
\ No newline at end of file
+        return None
+
+def declare_quorum_queue(channel, queue_name, dlx_name):
+    channel.exchange_declare(exchange=dlx_name, exchange_type='fanout')
+    channel.queue_declare(queue=f"{queue_name}_dlq", durable=True, arguments={'x-queue-type': 'quorum'})
+    channel.queue_bind(exchange=dlx_name, queue=f"{queue_name}_dlq")
+    channel.queue_declare(
+        queue=queue_name,
+        durable=True,
+        arguments={
+            'x-queue-type': 'quorum',
+            'x-dead-letter-exchange': dlx_name
+        }
+    )
\ No newline at end of file
diff --git a/api/routes/migration_routes.py b/api/routes/migration_routes.py
index f109396..5120ffa 100644
--- a/api/routes/migration_routes.py
+++ b/api/routes/migration_routes.py
@@ -1,61 +1,91 @@
 from fastapi import APIRouter, HTTPException
 import os
 import pika
-import redis
 import json
 import uuid
 from .. import models
+from .. import schema_comparer
+from .. import migration_db
+from .. import queues
 
 router = APIRouter()
 
-def get_redis_connection():
-    return redis.Redis(host=os.getenv("REDIS_HOST", "localhost"), port=int(os.getenv("REDIS_PORT", 6379)), db=0, decode_responses=True)
-
 @router.post("/migrate/start")
 def start_migration(request: models.DataMigrationRequest):
     if not all([request.oracle_credentials, request.postgres_credentials, request.source_table, request.destination_table]):
         raise HTTPException(status_code=400, detail="All fields are required.")
 
-    task_id = str(uuid.uuid4())
-    task_info = {
-        "task_id": task_id,
-        "oracle_credentials": request.oracle_credentials.dict(),
-        "postgres_credentials": request.postgres_credentials.dict(),
-        "source_table": request.source_table,
-        "destination_table": request.destination_table
-    }
+    # 1. Perform Schema Compatibility Check
+    try:
+        oracle_schema, postgres_schema = schema_comparer.get_table_schemas(
+            request.oracle_credentials,
+            request.source_table,
+            request.oracle_credentials.service_name or request.oracle_credentials.sid, # Assuming schema name is service_name/sid for simplicity
+            request.postgres_credentials,
+            request.destination_table
+        )
+        is_compatible, issues = schema_comparer.compare_schemas(oracle_schema, postgres_schema)
+
+        if not is_compatible:
+            raise HTTPException(
+                status_code=400,
+                detail={"message": "Schema incompatibility detected", "issues": issues}
+            )
+    except Exception as e:
+        raise HTTPException(status_code=500, detail=f"Schema comparison failed: {e}")
 
+    # 2. Create a new migration job in PostgreSQL
     try:
-        connection = pika.BlockingConnection(pika.ConnectionParameters(host=os.getenv('RABBITMQ_HOST', 'localhost')))
+        job_id = migration_db.create_migration_job(
+            source_db_type="Oracle",
+            source_connection_string=json.dumps(request.oracle_credentials.dict()),
+            source_table_name=request.source_table,
+            target_db_type="PostgreSQL",
+            target_connection_string=json.dumps(request.postgres_credentials.dict()),
+            target_table_name=request.destination_table
+        )
+    except Exception as e:
+        raise HTTPException(status_code=500, detail=f"Failed to create migration job: {e}")
+
+    # 3. Publish message to RabbitMQ for worker to pick up
+    try:
+        connection = queues.get_rabbitmq_connection()
+        if not connection:
+            raise HTTPException(status_code=500, detail="Failed to connect to RabbitMQ.")
         channel = connection.channel()
+
+        # Use the existing data_migration_jobs queue for initial job dispatch
+        # The worker will then break it down into row-level jobs
+        queue_config = queues.QUEUE_CONFIG['DATA_MIGRATION_ROW'] # This is for row-level, but the initial job is still 'data_migration_jobs'
+        # The original data_migration_jobs queue is declared in worker.py main function
+        # For now, we'll use a hardcoded queue name for the initial job dispatch
+        # TODO: Refactor worker.py to use QUEUE_CONFIG for data_migration_jobs as well
         channel.queue_declare(queue='data_migration_jobs', durable=True, arguments={'x-queue-type': 'quorum'})
+
+        message = {"job_id": str(job_id)}
         channel.basic_publish(
             exchange='',
             routing_key='data_migration_jobs',
-            body=json.dumps(task_info),
+            body=json.dumps(message),
             properties=pika.BasicProperties(delivery_mode=2) # make message persistent
         )
         connection.close()
 
-        # Set initial status in Redis
-        redis_conn = get_redis_connection()
-        initial_status = {"status": "submitted", "message": "Task has been submitted to the queue."}
-        redis_conn.set(f"migration_status:{task_id}", json.dumps(initial_status), ex=3600) # 1-hour expiry
+        migration_db.update_migration_job_status(job_id, "SUBMITTED")
 
-        return {"task_id": task_id}
+        return {"job_id": job_id, "message": "Migration job submitted successfully."}
     except Exception as e:
-        raise HTTPException(status_code=500, detail=f"Error submitting task: {e}")
+        migration_db.update_migration_job_status(job_id, "FAILED", error_details=str(e))
+        raise HTTPException(status_code=500, detail=f"Error submitting migration job to queue: {e}")
 
-@router.get("/migrate/status/{task_id}")
-def check_status(task_id: str):
-    if not task_id:
-        raise HTTPException(status_code=400, detail="Task ID is required.")
+@router.get("/migrate/status/{job_id}")
+def check_status(job_id: str):
+    if not job_id:
+        raise HTTPException(status_code=400, detail="Job ID is required.")
     try:
-        redis_conn = get_redis_connection()
-        status_json = redis_conn.get(f"migration_status:{task_id}")
-        if status_json:
-            status_data = json.loads(status_json)
-            return status_data
-        return {"status": "pending", "message": ""}
+        job = migration_db.get_migration_job(job_id)
+        if job:
+            return job.dict()
+        raise HTTPException(status_code=404, detail="Migration job not found.")
     except Exception as e:
-        raise HTTPException(status_code=500, detail=f"Error checking status: {e}")
+        raise HTTPException(status_code=500, detail=f"Error checking migration job status: {e}")
diff --git a/api/startup.py b/api/startup.py
index b9b092a..b776702 100644
--- a/api/startup.py
+++ b/api/startup.py
@@ -2,6 +2,7 @@ from fastapi import FastAPI
 import pika
 from . import database
 from . import queues
+from . import migration_db
 from contextlib import asynccontextmanager
 
 @asynccontextmanager
@@ -10,6 +11,7 @@ async def lifespan(app: FastAPI):
     database.create_jobs_table()
     database.create_ddl_jobs_table()
     database.create_sql_execution_jobs_table()
+    migration_db.create_migration_tables()
     
     # Declare queues on startup
     connection = queues.get_rabbitmq_connection()
@@ -27,17 +29,7 @@ def declare_queues(connection):
         channel = connection.channel()
         for object_type in queues.QUEUE_CONFIG:
             config = queues.QUEUE_CONFIG[object_type]
-            channel.exchange_declare(exchange=config['dlx'], exchange_type='fanout')
-            channel.queue_declare(queue=config['dlq'], durable=True, arguments={'x-queue-type': 'quorum'})
-            channel.queue_bind(exchange=config['dlx'], queue=config['dlq'])
-            channel.queue_declare(
-                queue=config['queue'],
-                durable=True,
-                arguments={
-                    'x-queue-type': 'quorum',
-                    'x-dead-letter-exchange': config['dlx']
-                }
-            )
+            queues.declare_quorum_queue(channel, config['queue'], config['dlx'])
         channel.close()
     except pika.exceptions.AMQPError as e:
         print(f"Failed to declare queues: {e}")
diff --git a/sql-assests/airline_data.sql b/sql-assests/airline_data.sql
deleted file mode 100644
index efdd6ec..0000000
--- a/sql-assests/airline_data.sql
+++ /dev/null
@@ -1,50 +0,0 @@
--- Oracle SQL Insert Statements for Airline Database
--- Countries
-INSERT INTO Countries (country_id, country_name) VALUES ('US', 'United States');
-INSERT INTO Countries (country_id, country_name) VALUES ('GB', 'United Kingdom');
-INSERT INTO Countries (country_id, country_name) VALUES ('JP', 'Japan');
-
--- Airports
-INSERT INTO Airports (airport_id, airport_name, city, country_id) VALUES ('JFK', 'John F. Kennedy International Airport', 'New York', 'US');
-INSERT INTO Airports (airport_id, airport_name, city, country_id) VALUES ('LAX', 'Los Angeles International Airport', 'Los Angeles', 'US');
-INSERT INTO Airports (airport_id, airport_name, city, country_id) VALUES ('LHR', 'Heathrow Airport', 'London', 'GB');
-INSERT INTO Airports (airport_id, airport_name, city, country_id) VALUES ('HND', 'Haneda Airport', 'Tokyo', 'JP');
-
--- Airlines
-INSERT INTO Airlines (airline_id, airline_name, iata_code) VALUES (1, 'American Airlines', 'AA');
-INSERT INTO Airlines (airline_id, airline_name, iata_code) VALUES (2, 'British Airways', 'BA');
-INSERT INTO Airlines (airline_id, airline_name, iata_code) VALUES (3, 'Japan Airlines', 'JL');
-
--- Aircraft
-INSERT INTO Aircraft (aircraft_id, airline_id, model, capacity) VALUES (101, 1, 'Boeing 777', 300);
-INSERT INTO Aircraft (aircraft_id, airline_id, model, capacity) VALUES (102, 1, 'Airbus A320', 180);
-INSERT INTO Aircraft (aircraft_id, airline_id, model, capacity) VALUES (201, 2, 'Boeing 787', 250);
-INSERT INTO Aircraft (aircraft_id, airline_id, model, capacity) VALUES (301, 3, 'Airbus A350', 320);
-
--- Flights
-INSERT INTO Flights (flight_id, flight_number, airline_id, aircraft_id, departure_airport_id, arrival_airport_id, departure_time, arrival_time)
-VALUES (1001, 'AA100', 1, 101, 'JFK', 'LHR', TO_TIMESTAMP('2025-10-20 20:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_TIMESTAMP('2025-10-21 08:00:00', 'YYYY-MM-DD HH24:MI:SS'));
-INSERT INTO Flights (flight_id, flight_number, airline_id, aircraft_id, departure_airport_id, arrival_airport_id, departure_time, arrival_time)
-VALUES (1002, 'BA282', 2, 201, 'LHR', 'LAX', TO_TIMESTAMP('2025-10-22 11:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_TIMESTAMP('2025-10-22 14:00:00', 'YYYY-MM-DD HH24:MI:SS'));
-INSERT INTO Flights (flight_id, flight_number, airline_id, aircraft_id, departure_airport_id, arrival_airport_id, departure_time, arrival_time)
-VALUES (1003, 'JL005', 3, 301, 'HND', 'JFK', TO_TIMESTAMP('2025-10-25 10:30:00', 'YYYY-MM-DD HH24:MI:SS'), TO_TIMESTAMP('2025-10-25 09:30:00', 'YYYY-MM-DD HH24:MI:SS'));
-
--- Passengers
-INSERT INTO Passengers (passenger_id, first_name, last_name, email, passport_number) VALUES (1, 'John', 'Smith', 'john.smith@example.com', 'A12345678');
-INSERT INTO Passengers (passenger_id, first_name, last_name, email, passport_number) VALUES (2, 'Jane', 'Doe', 'jane.doe@example.com', 'B87654321');
-
--- Bookings
-INSERT INTO Bookings (booking_id, flight_id, passenger_id, seat_number) VALUES (1, 1001, 1, '12A');
-INSERT INTO Bookings (booking_id, flight_id, passenger_id, seat_number) VALUES (2, 1002, 2, '22B');
-
--- Employees
-INSERT INTO Employees (employee_id, first_name, last_name, role) VALUES (10, 'William', 'Turner', 'Pilot');
-INSERT INTO Employees (employee_id, first_name, last_name, role) VALUES (11, 'Elizabeth', 'Swann', 'Pilot');
-INSERT INTO Employees (employee_id, first_name, last_name, role) VALUES (20, 'Jack', 'Sparrow', 'Cabin Crew');
-
--- Flight Crew
-INSERT INTO Flight_Crew (flight_crew_id, flight_id, employee_id, crew_role) VALUES (1, 1001, 10, 'Captain');
-INSERT INTO Flight_Crew (flight_crew_id, flight_id, employee_id, crew_role) VALUES (2, 1001, 11, 'First Officer');
-INSERT INTO Flight_Crew (flight_crew_id, flight_id, employee_id, crew_role) VALUES (3, 1001, 20, 'Flight Attendant');
-
-COMMIT;
diff --git a/sql-assests/airline_schema.sql b/sql-assests/airline_schema.sql
deleted file mode 100644
index 1ad5288..0000000
--- a/sql-assests/airline_schema.sql
+++ /dev/null
@@ -1,100 +0,0 @@
--- Oracle SQL Schema for an Airline Database
--- Change the current schema for the session to 'arul'
--- ALTER SESSION SET CURRENT_SCHEMA = C##arul;
-
--- Countries Table
-CREATE TABLE Countries (
-    country_id VARCHAR2(2) PRIMARY KEY,
-    country_name VARCHAR2(100) NOT NULL
-);
-
--- Airports Table
-CREATE TABLE Airports (
-    airport_id CHAR(3) PRIMARY KEY,
-    airport_name VARCHAR2(100) NOT NULL,
-    city VARCHAR2(100) NOT NULL,
-    country_id VARCHAR2(2) NOT NULL,
-    CONSTRAINT fk_airports_country FOREIGN KEY (country_id) REFERENCES Countries(country_id)
-);
-
--- Airlines Table
-CREATE TABLE Airlines (
-    airline_id NUMBER PRIMARY KEY,
-    airline_name VARCHAR2(100) NOT NULL,
-    iata_code VARCHAR2(2) UNIQUE
-);
-
--- Aircraft Table
-CREATE TABLE Aircraft (
-    aircraft_id NUMBER PRIMARY KEY,
-    airline_id NUMBER NOT NULL,
-    model VARCHAR2(100) NOT NULL,
-    capacity NUMBER NOT NULL,
-    CONSTRAINT fk_aircraft_airline FOREIGN KEY (airline_id) REFERENCES Airlines(airline_id)
-);
-
--- Flights Table
-CREATE TABLE Flights (
-    flight_id NUMBER PRIMARY KEY,
-    flight_number VARCHAR2(10) NOT NULL,
-    airline_id NUMBER NOT NULL,
-    aircraft_id NUMBER NOT NULL,
-    departure_airport_id CHAR(3) NOT NULL,
-    arrival_airport_id CHAR(3) NOT NULL,
-    departure_time TIMESTAMP NOT NULL,
-    arrival_time TIMESTAMP NOT NULL,
-    status VARCHAR2(20) DEFAULT 'Scheduled' NOT NULL,
-    CONSTRAINT fk_flights_airline FOREIGN KEY (airline_id) REFERENCES Airlines(airline_id),
-    CONSTRAINT fk_flights_aircraft FOREIGN KEY (aircraft_id) REFERENCES Aircraft(aircraft_id),
-    CONSTRAINT fk_flights_dep_airport FOREIGN KEY (departure_airport_id) REFERENCES Airports(airport_id),
-    CONSTRAINT fk_flights_arr_airport FOREIGN KEY (arrival_airport_id) REFERENCES Airports(airport_id)
-);
-
--- Passengers Table
-CREATE TABLE Passengers (
-    passenger_id NUMBER PRIMARY KEY,
-    first_name VARCHAR2(100) NOT NULL,
-    last_name VARCHAR2(100) NOT NULL,
-    email VARCHAR2(100) UNIQUE NOT NULL,
-    phone_number VARCHAR2(20),
-    passport_number VARCHAR2(20) UNIQUE
-);
-
--- Bookings Table
-CREATE TABLE Bookings (
-    booking_id NUMBER PRIMARY KEY,
-    flight_id NUMBER NOT NULL,
-    passenger_id NUMBER NOT NULL,
-    booking_date DATE DEFAULT SYSDATE NOT NULL,
-    seat_number VARCHAR2(4),
-    status VARCHAR2(20) DEFAULT 'Confirmed' NOT NULL,
-    CONSTRAINT fk_bookings_flight FOREIGN KEY (flight_id) REFERENCES Flights(flight_id),
-    CONSTRAINT fk_bookings_passenger FOREIGN KEY (passenger_id) REFERENCES Passengers(passenger_id)
-);
-
--- Boarding_Passes Table
-CREATE TABLE Boarding_Passes (
-    boarding_pass_id NUMBER PRIMARY KEY,
-    booking_id NUMBER NOT NULL,
-    gate VARCHAR2(5),
-    boarding_time TIMESTAMP,
-    CONSTRAINT fk_boarding_passes_booking FOREIGN KEY (booking_id) REFERENCES Bookings(booking_id)
-);
-
--- Employees Table
-CREATE TABLE Employees (
-    employee_id NUMBER PRIMARY KEY,
-    first_name VARCHAR2(100) NOT NULL,
-    last_name VARCHAR2(100) NOT NULL,
-    role VARCHAR2(50) NOT NULL -- e.g., 'Pilot', 'Cabin Crew', 'Ground Staff'
-);
-
--- Flight_Crew Table
-CREATE TABLE Flight_Crew (
-    flight_crew_id NUMBER PRIMARY KEY,
-    flight_id NUMBER NOT NULL,
-    employee_id NUMBER NOT NULL,
-    crew_role VARCHAR2(50) NOT NULL, -- e.g., 'Captain', 'First Officer', 'Flight Attendant'
-    CONSTRAINT fk_flight_crew_flight FOREIGN KEY (flight_id) REFERENCES Flights(flight_id),
-    CONSTRAINT fk_flight_crew_employee FOREIGN KEY (employee_id) REFERENCES Employees(employee_id)
-);
diff --git a/sql-assests/airline_sprocs.sql b/sql-assests/airline_sprocs.sql
deleted file mode 100644
index daeb169..0000000
--- a/sql-assests/airline_sprocs.sql
+++ /dev/null
@@ -1,82 +0,0 @@
--- GRANT ALTER ANY SESSION TO SYSTEM;
-
--- SELECT DBMS_METADATA.GET_DDL('TABLE', AIRLINE, 'DEMOARUL')
--- FROM all_tables
--- WHERE owner = 'DEMOARUL';
-
-
--- Oracle Stored Procedures for the Airline Database
--- Procedure to book a flight for a passenger
-CREATE OR REPLACE PROCEDURE Book_Flight (
-    p_flight_id IN NUMBER,
-    p_passenger_id IN NUMBER,
-    p_seat_number IN VARCHAR2
-)
-AS
-    v_booking_id NUMBER;
-BEGIN
-    -- Check if the flight exists
-    SELECT flight_id INTO v_booking_id FROM Flights WHERE flight_id = p_flight_id;
-
-    -- Check if the passenger exists
-    SELECT passenger_id INTO v_booking_id FROM Passengers WHERE passenger_id = p_passenger_id;
-
-    -- Create the booking
-    INSERT INTO Bookings (flight_id, passenger_id, seat_number)
-    VALUES (p_flight_id, p_passenger_id, p_seat_number);
-
-    COMMIT;
-EXCEPTION
-    WHEN NO_DATA_FOUND THEN
-        DBMS_OUTPUT.PUT_LINE('Error: Invalid flight ID or passenger ID.');
-        ROLLBACK;
-    WHEN OTHERS THEN
-        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
-        ROLLBACK;
-END Book_Flight;
-/
-
--- Procedure to get the flight schedule for a given route
-CREATE OR REPLACE PROCEDURE Get_Flight_Schedule (
-    p_departure_airport IN CHAR,
-    p_arrival_airport IN CHAR
-)
-AS
-    CURSOR c_flights IS
-        SELECT flight_number, departure_time, arrival_time, status
-        FROM Flights
-        WHERE departure_airport_id = p_departure_airport
-          AND arrival_airport_id = p_arrival_airport
-          AND status = 'Scheduled';
-BEGIN
-    DBMS_OUTPUT.PUT_LINE('Flight Schedule from ' || p_departure_airport || ' to ' || p_arrival_airport);
-    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
-    FOR r_flight IN c_flights LOOP
-        DBMS_OUTPUT.PUT_LINE(
-            'Flight: ' || r_flight.flight_number ||
-            ', Departs: ' || TO_CHAR(r_flight.departure_time, 'YYYY-MM-DD HH24:MI') ||
-            ', Arrives: ' || TO_CHAR(r_flight.arrival_time, 'YYYY-MM-DD HH24:MI')
-        );
-    END LOOP;
-    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
-END Get_Flight_Schedule;
-/
-
--- Procedure to assign crew to a flight
-CREATE OR REPLACE PROCEDURE Assign_Crew_To_Flight (
-    p_flight_id IN NUMBER,
-    p_employee_id IN NUMBER,
-    p_crew_role IN VARCHAR2
-)
-AS
-BEGIN
-    INSERT INTO Flight_Crew (flight_id, employee_id, crew_role)
-    VALUES (p_flight_id, p_employee_id, p_crew_role);
-
-    COMMIT;
-EXCEPTION
-    WHEN OTHERS THEN
-        DBMS_OUTPUT.PUT_LINE('Error assigning crew: ' || SQLERRM);
-        ROLLBACK;
-END Assign_Crew_To_Flight;
-/
diff --git a/sql-assests/converted.sql b/sql-assests/converted.sql
deleted file mode 100644
index bd7da29..0000000
--- a/sql-assests/converted.sql
+++ /dev/null
@@ -1 +0,0 @@
-{"job_ids": ["ed8f4372-9710-4b4b-9bb1-292a4936bf24", "9f739722-2078-45ac-8827-113dd99c9718", "176102b4-1810-4abe-886d-e582c1f0abf7", "776809a9-2d4e-4823-95a7-d131d4743cc0", "b9a65326-21c6-4670-b674-676cdf112b2b"]}
diff --git a/sql-assests/converted_arul.sql b/sql-assests/converted_arul.sql
deleted file mode 100644
index 4ff2711..0000000
--- a/sql-assests/converted_arul.sql
+++ /dev/null
@@ -1,263 +0,0 @@
-CREATE OR REPLACE FUNCTION sp_show_total_employees AS
-BEGIN
-  RAISE NOTICE('Total employees: ' || fn_get_total_employees);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_show_avg_salary(p_dept_id NUMERIC) AS
-BEGIN
-  RAISE NOTICE('Average salary: ' || fn_get_avg_salary(p_dept_id));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_simple_function AS
-BEGIN
-  RAISE NOTICE(fn_get_sysdate);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_params AS
-BEGIN
-  RAISE NOTICE(fn_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_string_function AS
-BEGIN
-  RAISE NOTICE(fn_get_greeting('World'));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_boolean_function AS
-  v_is_positive BOOLEAN;
-BEGIN
-  v_is_positive := fn_is_positive(10);
-  IF v_is_positive THEN
-    RAISE NOTICE('Positive');
-  END IF;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_query_function AS
-BEGIN
-  RAISE NOTICE('Employee count: ' || fn_get_employee_count);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_out_param AS
-  v_emp_name employees.employee_name%TYPE;
-  v_salary NUMERIC;
-BEGIN
-  v_salary := fn_get_employee(100, v_emp_name);
-  RAISE NOTICE('Name: ' || v_emp_name || ', Salary: ' || v_salary);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_in_out_param AS
-  v_num NUMERIC := 10;
-BEGIN
-  RAISE NOTICE('Original value: ' || v_num);
-  v_num := fn_double_value(v_num);
-  RAISE NOTICE('New value: ' || v_num);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_exception AS
-BEGIN
-  RAISE NOTICE(fn_divide(10, 0));
-EXCEPTION
-  WHEN division_by_zero THEN
-    RAISE NOTICE('Cannot divide by zero.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_math AS
-  FUNCTION fn_add(p_num1 NUMERIC, p_num2 NUMERIC) RETURNS NUMERIC AS
-  BEGIN
-    RETURNS p_num1 + p_num2;
-  END fn_add;
-
-  FUNCTION fn_subtract(p_num1 NUMERIC, p_num2 NUMERIC) RETURNS NUMERIC AS
-  BEGIN
-    RETURNS p_num1 - p_num2;
-  END fn_subtract;
-END pkg_math;
-
-CREATE OR REPLACE FUNCTION sp_call_package_function AS
-BEGIN
-  RAISE NOTICE(pkg_math.fn_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_private_function AS
-  FUNCTION fn_private_function RETURNS VARCHAR AS
-  BEGIN
-    RETURNS 'This is a private function.';
-  END fn_private_function;
-
-  PROCEDURE sp_public_proc AS
-  BEGIN
-    RAISE NOTICE(fn_private_function);
-  END sp_public_proc;
-END pkg_private_function;
-
-CREATE OR REPLACE FUNCTION sp_call_private_function_proc AS
-BEGIN
-  pkg_private_function.sp_public_proc;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_outer_proc_with_exception AS
-BEGIN
-  sp_inner_proc_with_exception;
-EXCEPTION
-  WHEN no_data_found THEN
-    RAISE NOTICE('Exception caught in outer procedure.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_exception_handling AS
-BEGIN
-  RAISE NOTICE(fn_exception_in_function);
-EXCEPTION
-  WHEN division_by_zero THEN
-    RAISE NOTICE('Exception from function caught in procedure.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_access_public_variable AS
-BEGIN
-  RAISE NOTICE(pkg_public_variable.g_public_variable);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_private_variable AS
-  g_private_variable VARCHAR(100) := 'This is a private variable.';
-
-  PROCEDURE sp_show_private_variable AS
-  BEGIN
-    RAISE NOTICE(g_private_variable);
-  END sp_show_private_variable;
-END pkg_private_variable;
-
-CREATE OR REPLACE FUNCTION sp_access_private_variable AS
-BEGIN
-  pkg_private_variable.sp_show_private_variable;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_overloading AS
-  PROCEDURE sp_overloaded(p_param IN NUMERIC) AS
-  BEGIN
-    RAISE NOTICE('Number: ' || p_param);
-  END sp_overloaded;
-
-  PROCEDURE sp_overloaded(p_param IN VARCHAR) AS
-  BEGIN
-    RAISE NOTICE('String: ' || p_param);
-  END sp_overloaded;
-END pkg_overloading;
-
-CREATE OR REPLACE FUNCTION sp_call_overloaded_proc AS
-BEGIN
-  pkg_overloading.sp_overloaded(123);
-  pkg_overloading.sp_overloaded('abc');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_forward_declaration AS
-  PROCEDURE sp_proc2; -- Forward declaration
-
-  PROCEDURE sp_proc1 AS
-  BEGIN
-    sp_proc2;
-  END sp_proc1;
-
-  PROCEDURE sp_proc2 AS
-  BEGIN
-    RAISE NOTICE('This is procedure 2.');
-  END sp_proc2;
-END pkg_forward_declaration;
-
-CREATE OR REPLACE PACKAGE BODY pkg_initialization AS
-BEGIN
-  g_initialized_variable := 'This variable was initialized in the package body.';
-END pkg_initialization;
-
-CREATE OR REPLACE FUNCTION sp_access_initialized_variable AS
-BEGIN
-  RAISE NOTICE(pkg_initialization.g_initialized_variable);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_cursor AS
-  PROCEDURE sp_show_departments AS
-  BEGIN
-    FOR dept_rec IN c_depts LOOP
-      RAISE NOTICE(dept_rec.department_name);
-    END LOOP;
-  END sp_show_departments;
-END pkg_cursor;
-
-CREATE OR REPLACE PACKAGE BODY pkg_record AS
-  PROCEDURE sp_show_employee(p_emp_id NUMERIC) AS
-    v_employee r_employee;
-  BEGIN
-    SELECT employee_name, salary INTO v_employee FROM employees WHERE employee_id = p_emp_id;
-    RAISE NOTICE('Name: ' || v_employee.name || ', Salary: ' || v_employee.salary);
-  END sp_show_employee;
-END pkg_record;
-
-CREATE OR REPLACE TYPE t_number_table AS TABLE OF t_number_row;
-
-CREATE OR REPLACE FUNCTION fn_pipelined_numbers(p_count NUMERIC) RETURNS t_number_table PIPELINED AS
-BEGIN
-  FOR i IN 1..p_count LOOP
-    PIPE ROW(t_number_row(i));
-  END LOOP;
-  RETURNS;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_pipelined_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_pipelined_numbers(5))) LOOP
-    RAISE NOTICE(rec.n);
-  END LOOP;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_table_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_table_function(5))) LOOP
-    RAISE NOTICE(rec.n);
-  END LOOP;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_deterministic_function AS
-BEGIN
-  RAISE NOTICE(fn_deterministic_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_result_cache_function AS
-BEGIN
-  RAISE NOTICE(fn_result_cache_function(10));
-  RAISE NOTICE(fn_result_cache_function(10)); -- This will be faster
-$$ LANGUAGE plpgsql;
-
--- Warnings --
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- Cursors have different syntax in PostgreSQL. In PL/pgSQL, FOR loops over queries require target variables to be explicitly declared. Please review and adapt the cursor logic manually.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
diff --git a/sql-assests/converted_file-new.sql b/sql-assests/converted_file-new.sql
deleted file mode 100644
index 4ff2711..0000000
--- a/sql-assests/converted_file-new.sql
+++ /dev/null
@@ -1,263 +0,0 @@
-CREATE OR REPLACE FUNCTION sp_show_total_employees AS
-BEGIN
-  RAISE NOTICE('Total employees: ' || fn_get_total_employees);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_show_avg_salary(p_dept_id NUMERIC) AS
-BEGIN
-  RAISE NOTICE('Average salary: ' || fn_get_avg_salary(p_dept_id));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_simple_function AS
-BEGIN
-  RAISE NOTICE(fn_get_sysdate);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_params AS
-BEGIN
-  RAISE NOTICE(fn_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_string_function AS
-BEGIN
-  RAISE NOTICE(fn_get_greeting('World'));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_boolean_function AS
-  v_is_positive BOOLEAN;
-BEGIN
-  v_is_positive := fn_is_positive(10);
-  IF v_is_positive THEN
-    RAISE NOTICE('Positive');
-  END IF;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_query_function AS
-BEGIN
-  RAISE NOTICE('Employee count: ' || fn_get_employee_count);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_out_param AS
-  v_emp_name employees.employee_name%TYPE;
-  v_salary NUMERIC;
-BEGIN
-  v_salary := fn_get_employee(100, v_emp_name);
-  RAISE NOTICE('Name: ' || v_emp_name || ', Salary: ' || v_salary);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_in_out_param AS
-  v_num NUMERIC := 10;
-BEGIN
-  RAISE NOTICE('Original value: ' || v_num);
-  v_num := fn_double_value(v_num);
-  RAISE NOTICE('New value: ' || v_num);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_exception AS
-BEGIN
-  RAISE NOTICE(fn_divide(10, 0));
-EXCEPTION
-  WHEN division_by_zero THEN
-    RAISE NOTICE('Cannot divide by zero.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_math AS
-  FUNCTION fn_add(p_num1 NUMERIC, p_num2 NUMERIC) RETURNS NUMERIC AS
-  BEGIN
-    RETURNS p_num1 + p_num2;
-  END fn_add;
-
-  FUNCTION fn_subtract(p_num1 NUMERIC, p_num2 NUMERIC) RETURNS NUMERIC AS
-  BEGIN
-    RETURNS p_num1 - p_num2;
-  END fn_subtract;
-END pkg_math;
-
-CREATE OR REPLACE FUNCTION sp_call_package_function AS
-BEGIN
-  RAISE NOTICE(pkg_math.fn_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_private_function AS
-  FUNCTION fn_private_function RETURNS VARCHAR AS
-  BEGIN
-    RETURNS 'This is a private function.';
-  END fn_private_function;
-
-  PROCEDURE sp_public_proc AS
-  BEGIN
-    RAISE NOTICE(fn_private_function);
-  END sp_public_proc;
-END pkg_private_function;
-
-CREATE OR REPLACE FUNCTION sp_call_private_function_proc AS
-BEGIN
-  pkg_private_function.sp_public_proc;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_outer_proc_with_exception AS
-BEGIN
-  sp_inner_proc_with_exception;
-EXCEPTION
-  WHEN no_data_found THEN
-    RAISE NOTICE('Exception caught in outer procedure.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_function_with_exception_handling AS
-BEGIN
-  RAISE NOTICE(fn_exception_in_function);
-EXCEPTION
-  WHEN division_by_zero THEN
-    RAISE NOTICE('Exception from function caught in procedure.');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_access_public_variable AS
-BEGIN
-  RAISE NOTICE(pkg_public_variable.g_public_variable);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_private_variable AS
-  g_private_variable VARCHAR(100) := 'This is a private variable.';
-
-  PROCEDURE sp_show_private_variable AS
-  BEGIN
-    RAISE NOTICE(g_private_variable);
-  END sp_show_private_variable;
-END pkg_private_variable;
-
-CREATE OR REPLACE FUNCTION sp_access_private_variable AS
-BEGIN
-  pkg_private_variable.sp_show_private_variable;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_overloading AS
-  PROCEDURE sp_overloaded(p_param IN NUMERIC) AS
-  BEGIN
-    RAISE NOTICE('Number: ' || p_param);
-  END sp_overloaded;
-
-  PROCEDURE sp_overloaded(p_param IN VARCHAR) AS
-  BEGIN
-    RAISE NOTICE('String: ' || p_param);
-  END sp_overloaded;
-END pkg_overloading;
-
-CREATE OR REPLACE FUNCTION sp_call_overloaded_proc AS
-BEGIN
-  pkg_overloading.sp_overloaded(123);
-  pkg_overloading.sp_overloaded('abc');
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_forward_declaration AS
-  PROCEDURE sp_proc2; -- Forward declaration
-
-  PROCEDURE sp_proc1 AS
-  BEGIN
-    sp_proc2;
-  END sp_proc1;
-
-  PROCEDURE sp_proc2 AS
-  BEGIN
-    RAISE NOTICE('This is procedure 2.');
-  END sp_proc2;
-END pkg_forward_declaration;
-
-CREATE OR REPLACE PACKAGE BODY pkg_initialization AS
-BEGIN
-  g_initialized_variable := 'This variable was initialized in the package body.';
-END pkg_initialization;
-
-CREATE OR REPLACE FUNCTION sp_access_initialized_variable AS
-BEGIN
-  RAISE NOTICE(pkg_initialization.g_initialized_variable);
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY pkg_cursor AS
-  PROCEDURE sp_show_departments AS
-  BEGIN
-    FOR dept_rec IN c_depts LOOP
-      RAISE NOTICE(dept_rec.department_name);
-    END LOOP;
-  END sp_show_departments;
-END pkg_cursor;
-
-CREATE OR REPLACE PACKAGE BODY pkg_record AS
-  PROCEDURE sp_show_employee(p_emp_id NUMERIC) AS
-    v_employee r_employee;
-  BEGIN
-    SELECT employee_name, salary INTO v_employee FROM employees WHERE employee_id = p_emp_id;
-    RAISE NOTICE('Name: ' || v_employee.name || ', Salary: ' || v_employee.salary);
-  END sp_show_employee;
-END pkg_record;
-
-CREATE OR REPLACE TYPE t_number_table AS TABLE OF t_number_row;
-
-CREATE OR REPLACE FUNCTION fn_pipelined_numbers(p_count NUMERIC) RETURNS t_number_table PIPELINED AS
-BEGIN
-  FOR i IN 1..p_count LOOP
-    PIPE ROW(t_number_row(i));
-  END LOOP;
-  RETURNS;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_pipelined_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_pipelined_numbers(5))) LOOP
-    RAISE NOTICE(rec.n);
-  END LOOP;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_table_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_table_function(5))) LOOP
-    RAISE NOTICE(rec.n);
-  END LOOP;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_deterministic_function AS
-BEGIN
-  RAISE NOTICE(fn_deterministic_add(10, 20));
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION sp_call_result_cache_function AS
-BEGIN
-  RAISE NOTICE(fn_result_cache_function(10));
-  RAISE NOTICE(fn_result_cache_function(10)); -- This will be faster
-$$ LANGUAGE plpgsql;
-
--- Warnings --
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- Cursors have different syntax in PostgreSQL. In PL/pgSQL, FOR loops over queries require target variables to be explicitly declared. Please review and adapt the cursor logic manually.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
diff --git a/sql-assests/converted_file.sql b/sql-assests/converted_file.sql
deleted file mode 100644
index 4a061c3..0000000
--- a/sql-assests/converted_file.sql
+++ /dev/null
@@ -1,91 +0,0 @@
-CREATE OR REPLACE FUNCTION EMP_SAL_RAISE
-(P_EMP_ID IN NUMERIC, SAL_RAISE IN NUMERIC)
-AS
-V_EMP_CURRENT_SAL NUMERIC;
-BEGIN
-SELECT SALARY INTO V_EMP_CURRENT_SAL FROM EMPLOYEES WHERE EMPLOYEE_ID=P_EMP_ID;
-UPDATE EMPLOYEES
-SET SALARY=V_EMP_CURRENT_SAL+SAL_RAISE
-WHERE EMPLOYEE_ID=P_EMP_ID;
-RAISE NOTICE('New Salary For Employee ID: '||P_EMP_ID||' Is '||(V_EMP_CURRENT_
-SAL+SAL_RAISE));
-EXCEPTION WHEN OTHERS THEN
-RAISE EXCEPTION(-20001,'An error was encountered
-'||SQLCODE||' -ERROR-
-'||SQLERRM);
-ROLLBACK;
-COMMIT;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION EMP_PERIOD_OF_SERVICE_YEAR
-(P_EMP_ID NUMERIC)
-RETURNS NUMERIC
-AS
-V_PERIOD_OF_SERVICE_YEARS NUMERIC;
-BEGIN
-SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM TO_DATE(HIRE_DATE)) INTO
-V_PERIOD_OF_SERVICE_YEARS
-FROM EMPLOYEES
-WHERE EMPLOYEE_ID=P_EMP_ID;
-RETURNS V_PERIOD_OF_SERVICE_YEARS;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE PCK_CHINOOK_REPORTS
-AS
-PROCEDURE GET_ARTIST_BY_ALBUM(P_ARTIST_ID ALBUM.TITLE%TYPE);
-PROCEDURE CUST_INVOICE_BY_YEAR_ANALYZE;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE PACKAGE BODY PCK_CHINOOK_REPORTS
-AS
-PROCEDURE GET_ARTIST_BY_ALBUM(P_ARTIST_ID ALBUM.TITLE%TYPE)
-IS
-V_ARTIST_NAME ARTIST.NAME%TYPE;
-BEGIN
-SELECT ART.NAME INTO V_ARTIST_NAME
-FROM ALBUM ALB JOIN ARTIST ART USING(ARTISTID)
-WHERE ALB.TITLE=P_ARTIST_ID;
-RAISE NOTICE('ArtistName: '||V_ARTIST_NAME);
-$$ LANGUAGE plpgsql;
-PROCEDURE CUST_INVOICE_BY_YEAR_ANALYZE
-AS
-V_CUST_GENRES VARCHAR(200);
-BEGIN
-FOR V IN(SELECT CUSTOMERID, CUSTNAME, LOW_YEAR, HIGH_YEAR, CUST_AVG FROM TMP_CUST_
-INVOICE_ANALYSE)
-LOOP
-IF SUBSTRING(V.LOW_YEAR, -4) > SUBSTRING(V.HIGH_YEAR , -4) THEN
-SELECT LISTAGG(GENRE, ',') WITHIN GROUP (ORDER BY GENRE) INTO V_CUST_GENRES FROM
-(SELECT DISTINCT
-FUNC_GENRE_BY_ID(TRC.GENREID) AS GENRE
-FROM TMP_CUST_INVOICE_ANALYSE TMPTBL JOIN INVOICE INV USING(CUSTOMERID)
-JOIN INVOICELINE ICOALESCEIN
-ON INV.INVOICEID = ICOALESCEIN.INVOICEID
-JOIN TRACK TRC
-ON TRC.TRACKID = ICOALESCEIN.TRACKID
-WHERE CUSTOMERID=V.CUSTOMERID);
-RAISE NOTICE('Customer: '||UPPER(V.CUSTNAME)||' - Offer a Discount According
-To Preferred Genres: '||UPPER(V_CUST_GENRES));
-END IF;
-END LOOP;
-$$ LANGUAGE plpgsql;
-$$ LANGUAGE plpgsql;
-
-CREATE OR REPLACE FUNCTION TOTAL_EMP_SAL_BY_YEARS
-(p_hire_date DATE, p_current_sal NUMERIC)
-RETURNS NUMERIC
-AS
-v_years_of_service NUMERIC;
-v_total_sal_by_years NUMERIC;
-BEGIN
-SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM to_date(p_hire_date))
-INTO v_years_of_service FROM dual;
-v_total_sal_by_years:=p_current_sal*v_years_of_service;
-RETURNS v_total_sal_by_years;
-$$ LANGUAGE plpgsql;
-
--- Warnings --
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
--- DBMS_OUTPUT is not available in PostgreSQL. Use 'RAISE NOTICE' for similar functionality.
--- PostgreSQL uses schemas to organize functions instead of packages. Package-level variables are not supported; you can use temporary tables for per-session state. Consider creating a schema to group the functions from the package.
diff --git a/sql-assests/oracle-sp-new.sql b/sql-assests/oracle-sp-new.sql
deleted file mode 100644
index 404711d..0000000
--- a/sql-assests/oracle-sp-new.sql
+++ /dev/null
@@ -1,90 +0,0 @@
-CREATE OR REPLACE PROCEDURE EMP_SAL_RAISE
-(P_EMP_ID IN NUMBER, SAL_RAISE IN NUMBER)
-AS
-V_EMP_CURRENT_SAL NUMBER;
-BEGIN
-SELECT SALARY INTO V_EMP_CURRENT_SAL FROM EMPLOYEES WHERE EMPLOYEE_ID=P_EMP_ID;
-UPDATE EMPLOYEES
-SET SALARY=V_EMP_CURRENT_SAL+SAL_RAISE
-WHERE EMPLOYEE_ID=P_EMP_ID;
-DBMS_OUTPUT.PUT_LINE('New Salary For Employee ID: '||P_EMP_ID||' Is '||(V_EMP_CURRENT_
-SAL+SAL_RAISE));
-EXCEPTION WHEN OTHERS THEN
-RAISE_APPLICATION_ERROR(-20001,'An error was encountered
-'||SQLCODE||' -ERROR-
-'||SQLERRM);
-ROLLBACK;
-COMMIT;
-END;
-/
-
-CREATE OR REPLACE FUNCTION EMP_PERIOD_OF_SERVICE_YEAR
-(P_EMP_ID NUMBER)
-RETURN NUMBER
-AS
-V_PERIOD_OF_SERVICE_YEARS NUMBER;
-BEGIN
-SELECT EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(HIRE_DATE)) INTO
-V_PERIOD_OF_SERVICE_YEARS
-FROM EMPLOYEES
-WHERE EMPLOYEE_ID=P_EMP_ID;
-RETURN V_PERIOD_OF_SERVICE_YEARS;
-END;
-/
-
-CREATE OR REPLACE PACKAGE PCK_CHINOOK_REPORTS
-AS
-PROCEDURE GET_ARTIST_BY_ALBUM(P_ARTIST_ID ALBUM.TITLE%TYPE);
-PROCEDURE CUST_INVOICE_BY_YEAR_ANALYZE;
-END;
-/
-
-CREATE OR REPLACE PACKAGE BODY PCK_CHINOOK_REPORTS
-AS
-PROCEDURE GET_ARTIST_BY_ALBUM(P_ARTIST_ID ALBUM.TITLE%TYPE)
-IS
-V_ARTIST_NAME ARTIST.NAME%TYPE;
-BEGIN
-SELECT ART.NAME INTO V_ARTIST_NAME
-FROM ALBUM ALB JOIN ARTIST ART USING(ARTISTID)
-WHERE ALB.TITLE=P_ARTIST_ID;
-DBMS_OUTPUT.PUT_LINE('ArtistName: '||V_ARTIST_NAME);
-END;
-PROCEDURE CUST_INVOICE_BY_YEAR_ANALYZE
-AS
-V_CUST_GENRES VARCHAR2(200);
-BEGIN
-FOR V IN(SELECT CUSTOMERID, CUSTNAME, LOW_YEAR, HIGH_YEAR, CUST_AVG FROM TMP_CUST_
-INVOICE_ANALYSE)
-LOOP
-IF SUBSTR(V.LOW_YEAR, -4) > SUBSTR(V.HIGH_YEAR , -4) THEN
-SELECT LISTAGG(GENRE, ',') WITHIN GROUP (ORDER BY GENRE) INTO V_CUST_GENRES FROM
-(SELECT DISTINCT
-FUNC_GENRE_BY_ID(TRC.GENREID) AS GENRE
-FROM TMP_CUST_INVOICE_ANALYSE TMPTBL JOIN INVOICE INV USING(CUSTOMERID)
-JOIN INVOICELINE INVLIN
-ON INV.INVOICEID = INVLIN.INVOICEID
-JOIN TRACK TRC
-ON TRC.TRACKID = INVLIN.TRACKID
-WHERE CUSTOMERID=V.CUSTOMERID);
-DBMS_OUTPUT.PUT_LINE('Customer: '||UPPER(V.CUSTNAME)||' - Offer a Discount According
-To Preferred Genres: '||UPPER(V_CUST_GENRES));
-END IF;
-END LOOP;
-END;
-END;
-/
-
-CREATE OR REPLACE FUNCTION TOTAL_EMP_SAL_BY_YEARS
-(p_hire_date DATE, p_current_sal NUMBER)
-RETURN NUMBER
-AS
-v_years_of_service NUMBER;
-v_total_sal_by_years NUMBER;
-BEGIN
-SELECT EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM to_date(p_hire_date))
-INTO v_years_of_service FROM dual;
-v_total_sal_by_years:=p_current_sal*v_years_of_service;
-RETURN v_total_sal_by_years;
-END;
-/
diff --git a/sql-assests/oracle-sp.sql b/sql-assests/oracle-sp.sql
deleted file mode 100644
index bd59a6e..0000000
--- a/sql-assests/oracle-sp.sql
+++ /dev/null
@@ -1,1224 +0,0 @@
--- Oracle Stored Procedure Examples
-
--- Basic Procedures
--- 1. Simple Hello World
-CREATE OR REPLACE PROCEDURE sp_hello_world AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Hello World!');
-END;
-/
-
--- 2. Procedure to show current date
-CREATE OR REPLACE PROCEDURE sp_show_date AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(SYSDATE);
-END;
-/
-
--- 3. Procedure with a simple calculation
-CREATE OR REPLACE PROCEDURE sp_simple_calc AS
-  v_result NUMBER;
-BEGIN
-  v_result := 10 + 20;
-  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
-END;
-/
-
--- Procedures with Parameters
--- 4. Procedure with IN parameter
-CREATE OR REPLACE PROCEDURE sp_greet_person(p_name IN VARCHAR2) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name);
-END;
-/
-
--- 5. Procedure with OUT parameter
-CREATE OR REPLACE PROCEDURE sp_get_pi(p_pi OUT NUMBER) AS
-BEGIN
-  p_pi := 3.14159;
-END;
-/
-
--- 6. Procedure with IN OUT parameter
-CREATE OR REPLACE PROCEDURE sp_square_number(p_num IN OUT NUMBER) AS
-BEGIN
-  p_num := p_num * p_num;
-END;
-/
-
--- 7. Procedure with multiple parameters
-CREATE OR REPLACE PROCEDURE sp_add_numbers(p_num1 IN NUMBER, p_num2 IN NUMBER, p_sum OUT NUMBER) AS
-BEGIN
-  p_sum := p_num1 + p_num2;
-END;
-/
-
--- Procedures with DML
--- 8. Procedure to insert a new employee
-CREATE OR REPLACE PROCEDURE sp_add_employee(p_emp_name VARCHAR2, p_salary NUMBER) AS
-BEGIN
-  INSERT INTO employees (employee_name, salary) VALUES (p_emp_name, p_salary);
-  COMMIT;
-END;
-/
-
--- 9. Procedure to update an employee's salary
-CREATE OR REPLACE PROCEDURE sp_update_salary(p_emp_id NUMBER, p_new_salary NUMBER) AS
-BEGIN
-  UPDATE employees SET salary = p_new_salary WHERE employee_id = p_emp_id;
-  COMMIT;
-END;
-/
-
--- 10. Procedure to delete an employee
-CREATE OR REPLACE PROCEDURE sp_delete_employee(p_emp_id NUMBER) AS
-BEGIN
-  DELETE FROM employees WHERE employee_id = p_emp_id;
-  COMMIT;
-END;
-/
-
--- Procedures with Cursors
--- 11. Simple cursor to fetch employee names
-CREATE OR REPLACE PROCEDURE sp_get_employee_names AS
-  CURSOR c_emp IS SELECT employee_name FROM employees;
-  v_emp_name employees.employee_name%TYPE;
-BEGIN
-  OPEN c_emp;
-  LOOP
-    FETCH c_emp INTO v_emp_name;
-    EXIT WHEN c_emp%NOTFOUND;
-    DBMS_OUTPUT.PUT_LINE(v_emp_name);
-  END LOOP;
-  CLOSE c_emp;
-END;
-/
-
--- 12. Cursor with parameter
-CREATE OR REPLACE PROCEDURE sp_get_employees_by_dept(p_dept_id NUMBER) AS
-  CURSOR c_emp IS SELECT employee_name FROM employees WHERE department_id = p_dept_id;
-  v_emp_name employees.employee_name%TYPE;
-BEGIN
-  FOR emp_rec IN c_emp LOOP
-    DBMS_OUTPUT.PUT_LINE(emp_rec.employee_name);
-  END LOOP;
-END;
-/
-
--- 13. Cursor with FOR UPDATE
-CREATE OR REPLACE PROCEDURE sp_increase_salary_by_dept(p_dept_id NUMBER) AS
-  CURSOR c_emp IS SELECT salary FROM employees WHERE department_id = p_dept_id FOR UPDATE;
-BEGIN
-  FOR emp_rec IN c_emp LOOP
-    UPDATE employees SET salary = emp_rec.salary * 1.10 WHERE CURRENT OF c_emp;
-  END LOOP;
-END;
-/
-
--- Procedures with Functions
--- 14. Procedure calling a simple function
-CREATE OR REPLACE FUNCTION fn_get_total_employees RETURN NUMBER AS
-  v_total NUMBER;
-BEGIN
-  SELECT COUNT(*) INTO v_total FROM employees;
-  RETURN v_total;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_show_total_employees AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Total employees: ' || fn_get_total_employees);
-END;
-/
-
--- 15. Procedure with a function that takes a parameter
-CREATE OR REPLACE FUNCTION fn_get_avg_salary(p_dept_id NUMBER) RETURN NUMBER AS
-  v_avg_salary NUMBER;
-BEGIN
-  SELECT AVG(salary) INTO v_avg_salary FROM employees WHERE department_id = p_dept_id;
-  RETURN v_avg_salary;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_show_avg_salary(p_dept_id NUMBER) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Average salary: ' || fn_get_avg_salary(p_dept_id));
-END;
-/
-
--- Procedures with Exception Handling
--- 16. Simple exception handling
-CREATE OR REPLACE PROCEDURE sp_divide_by_zero AS
-  v_result NUMBER;
-BEGIN
-  v_result := 10 / 0;
-EXCEPTION
-  WHEN ZERO_DIVIDE THEN
-    DBMS_OUTPUT.PUT_LINE('Cannot divide by zero!');
-END;
-/
-
--- 17. Handling NO_DATA_FOUND
-CREATE OR REPLACE PROCEDURE sp_get_employee_name(p_emp_id NUMBER) AS
-  v_emp_name employees.employee_name%TYPE;
-BEGIN
-  SELECT employee_name INTO v_emp_name FROM employees WHERE employee_id = p_emp_id;
-  DBMS_OUTPUT.PUT_LINE('Employee name: ' || v_emp_name);
-EXCEPTION
-  WHEN NO_DATA_FOUND THEN
-    DBMS_OUTPUT.PUT_LINE('Employee not found.');
-END;
-/
-
--- 18. Handling TOO_MANY_ROWS
-CREATE OR REPLACE PROCEDURE sp_get_single_employee AS
-  v_emp_name employees.employee_name%TYPE;
-BEGIN
-  SELECT employee_name INTO v_emp_name FROM employees;
-EXCEPTION
-  WHEN TOO_MANY_ROWS THEN
-    DBMS_OUTPUT.PUT_LINE('More than one employee found.');
-END;
-/
-
--- 19. User-defined exception
-CREATE OR REPLACE PROCEDURE sp_check_salary(p_salary NUMBER) AS
-  e_invalid_salary EXCEPTION;
-BEGIN
-  IF p_salary <= 0 THEN
-    RAISE e_invalid_salary;
-  END IF;
-EXCEPTION
-  WHEN e_invalid_salary THEN
-    DBMS_OUTPUT.PUT_LINE('Salary must be greater than zero.');
-END;
-/
-
--- Procedures in Packages
--- 20. Package Specification
-CREATE OR REPLACE PACKAGE pkg_employee AS
-  PROCEDURE sp_add_employee(p_emp_name VARCHAR2, p_salary NUMBER);
-  PROCEDURE sp_delete_employee(p_emp_id NUMBER);
-  FUNCTION fn_get_total_employees RETURN NUMBER;
-END pkg_employee;
-/
-
--- 21. Package Body
-CREATE OR REPLACE PACKAGE BODY pkg_employee AS
-  PROCEDURE sp_add_employee(p_emp_name VARCHAR2, p_salary NUMBER) AS
-  BEGIN
-    INSERT INTO employees (employee_name, salary) VALUES (p_emp_name, p_salary);
-    COMMIT;
-  END sp_add_employee;
-
-  PROCEDURE sp_delete_employee(p_emp_id NUMBER) AS
-  BEGIN
-    DELETE FROM employees WHERE employee_id = p_emp_id;
-    COMMIT;
-  END sp_delete_employee;
-
-  FUNCTION fn_get_total_employees RETURN NUMBER AS
-    v_total NUMBER;
-  BEGIN
-    SELECT COUNT(*) INTO v_total FROM employees;
-    RETURN v_total;
-  END fn_get_total_employees;
-END pkg_employee;
-/
-
--- Advanced Procedures
--- 22. Procedure with Autonomous Transaction
-CREATE OR REPLACE PROCEDURE sp_log_error(p_error_message VARCHAR2) AS
-  PRAGMA AUTONOMOUS_TRANSACTION;
-BEGIN
-  INSERT INTO error_log (error_message, log_date) VALUES (p_error_message, SYSDATE);
-  COMMIT;
-END;
-/
-
--- 23. Procedure with Dynamic SQL
-CREATE OR REPLACE PROCEDURE sp_create_table(p_table_name VARCHAR2) AS
-BEGIN
-  EXECUTE IMMEDIATE 'CREATE TABLE ' || p_table_name || ' (id NUMBER, name VARCHAR2(100))';
-END;
-/
-
--- 24. Procedure with Bulk Collect
-CREATE OR REPLACE PROCEDURE sp_get_all_employees AS
-  TYPE t_emp_names IS TABLE OF employees.employee_name%TYPE;
-  v_emp_names t_emp_names;
-BEGIN
-  SELECT employee_name BULK COLLECT INTO v_emp_names FROM employees;
-  FOR i IN 1..v_emp_names.COUNT LOOP
-    DBMS_OUTPUT.PUT_LINE(v_emp_names(i));
-  END LOOP;
-END;
-/
-
--- 25. Procedure with Record Type
-CREATE OR REPLACE PROCEDURE sp_get_employee_details(p_emp_id NUMBER) AS
-  TYPE r_employee IS RECORD (
-    name employees.employee_name%TYPE,
-    salary employees.salary%TYPE
-  );
-  v_employee r_employee;
-BEGIN
-  SELECT employee_name, salary INTO v_employee FROM employees WHERE employee_id = p_emp_id;
-  DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.name || ', Salary: ' || v_employee.salary);
-END;
-/
-
--- 26. Procedure with conditional logic
-CREATE OR REPLACE PROCEDURE sp_check_number(p_num IN NUMBER) AS
-BEGIN
-  IF p_num > 0 THEN
-    DBMS_OUTPUT.PUT_LINE('Positive');
-  ELSIF p_num < 0 THEN
-    DBMS_OUTPUT.PUT_LINE('Negative');
-  ELSE
-    DBMS_OUTPUT.PUT_LINE('Zero');
-  END IF;
-END;
-/
-
--- 27. Procedure with a WHILE loop
-CREATE OR REPLACE PROCEDURE sp_while_loop_example AS
-  v_counter NUMBER := 1;
-BEGIN
-  WHILE v_counter <= 5 LOOP
-    DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
-    v_counter := v_counter + 1;
-  END LOOP;
-END;
-/
-
--- 28. Procedure with a FOR loop
-CREATE OR REPLACE PROCEDURE sp_for_loop_example AS
-BEGIN
-  FOR i IN 1..5 LOOP
-    DBMS_OUTPUT.PUT_LINE('Iteration: ' || i);
-  END LOOP;
-END;
-/
-
--- 29. Procedure with a GOTO statement
-CREATE OR REPLACE PROCEDURE sp_goto_example AS
-BEGIN
-  GOTO second_message;
-  <<first_message>>
-  DBMS_OUTPUT.PUT_LINE('This will be skipped.');
-  GOTO end_of_procedure;
-  <<second_message>>
-  DBMS_OUTPUT.PUT_LINE('This is the second message.');
-  <<end_of_procedure>>
-  NULL;
-END;
-/
-
--- 30. Procedure with NVL function
-CREATE OR REPLACE PROCEDURE sp_nvl_example(p_input VARCHAR2) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(NVL(p_input, 'Default Value'));
-END;
-/
-
--- 31. Procedure with SYSDATE
-CREATE OR REPLACE PROCEDURE sp_show_time AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(TO_CHAR(SYSDATE, 'HH24:MI:SS'));
-END;
-/
-
--- 32. Procedure with CLOB data type
-CREATE OR REPLACE PROCEDURE sp_process_clob(p_clob IN CLOB) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('CLOB length: ' || DBMS_LOB.getlength(p_clob));
-END;
-/
-
--- 33. Procedure with NUMBER data type
-CREATE OR REPLACE PROCEDURE sp_process_number(p_num IN NUMBER) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Number: ' || p_num);
-END;
-/
-
--- 34. Procedure with NVARCHAR2 data type
-CREATE OR REPLACE PROCEDURE sp_process_nvarchar2(p_text IN NVARCHAR2) AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('NVARCHAR2: ' || p_text);
-END;
-/
-
--- 35. Procedure with a simple cursor and loop
-CREATE OR REPLACE PROCEDURE sp_simple_cursor_loop AS
-  CURSOR c_depts IS SELECT department_name FROM departments;
-BEGIN
-  FOR dept_rec IN c_depts LOOP
-    DBMS_OUTPUT.PUT_LINE(dept_rec.department_name);
-  END LOOP;
-END;
-/
-
--- 36. Procedure with explicit cursor opening, fetching, and closing
-CREATE OR REPLACE PROCEDURE sp_explicit_cursor AS
-  CURSOR c_jobs IS SELECT job_title FROM jobs;
-  v_job_title jobs.job_title%TYPE;
-BEGIN
-  OPEN c_jobs;
-  LOOP
-    FETCH c_jobs INTO v_job_title;
-    EXIT WHEN c_jobs%NOTFOUND;
-    DBMS_OUTPUT.PUT_LINE(v_job_title);
-  END LOOP;
-  CLOSE c_jobs;
-END;
-/
-
--- 37. Procedure with a cursor and a parameter
-CREATE OR REPLACE PROCEDURE sp_get_locations_by_country(p_country_id VARCHAR2) AS
-  CURSOR c_locations IS SELECT city FROM locations WHERE country_id = p_country_id;
-BEGIN
-  FOR loc_rec IN c_locations LOOP
-    DBMS_OUTPUT.PUT_LINE(loc_rec.city);
-  END LOOP;
-END;
-/
-
--- 38. Procedure with a cursor and multiple columns
-CREATE OR REPLACE PROCEDURE sp_get_all_departments AS
-  CURSOR c_depts IS SELECT department_id, department_name FROM departments;
-  v_dept_id departments.department_id%TYPE;
-  v_dept_name departments.department_name%TYPE;
-BEGIN
-  OPEN c_depts;
-  LOOP
-    FETCH c_depts INTO v_dept_id, v_dept_name;
-    EXIT WHEN c_depts%NOTFOUND;
-    DBMS_OUTPUT.PUT_LINE('ID: ' || v_dept_id || ', Name: ' || v_dept_name);
-  END LOOP;
-  CLOSE c_depts;
-END;
-/
-
--- 39. Procedure with a cursor and a record
-CREATE OR REPLACE PROCEDURE sp_get_all_jobs AS
-  CURSOR c_jobs IS SELECT job_id, job_title FROM jobs;
-  r_job c_jobs%ROWTYPE;
-BEGIN
-  OPEN c_jobs;
-  LOOP
-    FETCH c_jobs INTO r_job;
-    EXIT WHEN c_jobs%NOTFOUND;
-    DBMS_OUTPUT.PUT_LINE('ID: ' || r_job.job_id || ', Title: ' || r_job.job_title);
-  END LOOP;
-  CLOSE c_jobs;
-END;
-/
-
--- 40. Procedure with a cursor and a FOR UPDATE clause
-CREATE OR REPLACE PROCEDURE sp_update_job_titles AS
-  CURSOR c_jobs IS SELECT job_title FROM jobs FOR UPDATE;
-BEGIN
-  FOR job_rec IN c_jobs LOOP
-    UPDATE jobs SET job_title = job_rec.job_title || ' (Updated)' WHERE CURRENT OF c_jobs;
-  END LOOP;
-END;
-/
-
--- 41. Procedure with a cursor and a WHERE CURRENT OF clause
-CREATE OR REPLACE PROCEDURE sp_delete_jobs_by_title(p_title VARCHAR2) AS
-  CURSOR c_jobs IS SELECT job_id FROM jobs WHERE job_title LIKE p_title FOR UPDATE;
-BEGIN
-  FOR job_rec IN c_jobs LOOP
-    DELETE FROM jobs WHERE CURRENT OF c_jobs;
-  END LOOP;
-END;
-/
-
--- 42. Procedure with a cursor and a subquery
-CREATE OR REPLACE PROCEDURE sp_get_employees_in_usa AS
-  CURSOR c_emps IS
-    SELECT e.employee_name
-    FROM employees e
-    JOIN departments d ON e.department_id = d.department_id
-    JOIN locations l ON d.location_id = l.location_id
-    WHERE l.country_id = 'US';
-BEGIN
-  FOR emp_rec IN c_emps LOOP
-    DBMS_OUTPUT.PUT_LINE(emp_rec.employee_name);
-  END LOOP;
-END;
-/
-
--- 43. Procedure with a cursor and an aggregate function
-CREATE OR REPLACE PROCEDURE sp_get_department_stats AS
-  CURSOR c_depts IS
-    SELECT d.department_name, COUNT(e.employee_id) AS num_employees
-    FROM departments d
-    LEFT JOIN employees e ON d.department_id = e.department_id
-    GROUP BY d.department_name;
-BEGIN
-  FOR dept_rec IN c_depts LOOP
-    DBMS_OUTPUT.PUT_LINE(dept_rec.department_name || ': ' || dept_rec.num_employees);
-  END LOOP;
-END;
-/
-
--- 44. Procedure with a cursor and a join
-CREATE OR REPLACE PROCEDURE sp_get_employee_department_names AS
-  CURSOR c_emps IS
-    SELECT e.employee_name, d.department_name
-    FROM employees e
-    JOIN departments d ON e.department_id = d.department_id;
-BEGIN
-  FOR emp_rec IN c_emps LOOP
-    DBMS_OUTPUT.PUT_LINE(emp_rec.employee_name || ' - ' || emp_rec.department_name);
-  END LOOP;
-END;
-/
-
--- 45. Procedure with a simple function call
-CREATE OR REPLACE FUNCTION fn_get_sysdate RETURN DATE AS
-BEGIN
-  RETURN SYSDATE;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_simple_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_get_sysdate);
-END;
-/
-
--- 46. Procedure with a function that has parameters
-CREATE OR REPLACE FUNCTION fn_add(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER AS
-BEGIN
-  RETURN p_num1 + p_num2;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_function_with_params AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_add(10, 20));
-END;
-/
-
--- 47. Procedure with a function that returns a string
-CREATE OR REPLACE FUNCTION fn_get_greeting(p_name VARCHAR2) RETURN VARCHAR2 AS
-BEGIN
-  RETURN 'Hello, ' || p_name;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_string_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_get_greeting('World'));
-END;
-/
-
--- 48. Procedure with a function that returns a boolean
-CREATE OR REPLACE FUNCTION fn_is_positive(p_num NUMBER) RETURN BOOLEAN AS
-BEGIN
-  RETURN p_num > 0;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_boolean_function AS
-  v_is_positive BOOLEAN;
-BEGIN
-  v_is_positive := fn_is_positive(10);
-  IF v_is_positive THEN
-    DBMS_OUTPUT.PUT_LINE('Positive');
-  END IF;
-END;
-/
-
--- 49. Procedure with a function that queries a table
-CREATE OR REPLACE FUNCTION fn_get_employee_count RETURN NUMBER AS
-  v_count NUMBER;
-BEGIN
-  SELECT COUNT(*) INTO v_count FROM employees;
-  RETURN v_count;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_query_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Employee count: ' || fn_get_employee_count);
-END;
-/
-
--- 50. Procedure with a function that has an OUT parameter
-CREATE OR REPLACE FUNCTION fn_get_employee(p_emp_id NUMBER, p_emp_name OUT VARCHAR2) RETURN NUMBER AS
-  v_salary NUMBER;
-BEGIN
-  SELECT employee_name, salary INTO p_emp_name, v_salary FROM employees WHERE employee_id = p_emp_id;
-  RETURN v_salary;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_function_with_out_param AS
-  v_emp_name employees.employee_name%TYPE;
-  v_salary NUMBER;
-BEGIN
-  v_salary := fn_get_employee(100, v_emp_name);
-  DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp_name || ', Salary: ' || v_salary);
-END;
-/
-
--- 51. Procedure with a function that has an IN OUT parameter
-CREATE OR REPLACE FUNCTION fn_double_value(p_num IN OUT NUMBER) RETURN NUMBER AS
-BEGIN
-  p_num := p_num * 2;
-  RETURN p_num;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_function_with_in_out_param AS
-  v_num NUMBER := 10;
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Original value: ' || v_num);
-  v_num := fn_double_value(v_num);
-  DBMS_OUTPUT.PUT_LINE('New value: ' || v_num);
-END;
-/
-
--- 52. Procedure with a function that raises an exception
-CREATE OR REPLACE FUNCTION fn_divide(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER AS
-BEGIN
-  IF p_num2 = 0 THEN
-    RAISE ZERO_DIVIDE;
-  END IF;
-  RETURN p_num1 / p_num2;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_function_with_exception AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_divide(10, 0));
-EXCEPTION
-  WHEN ZERO_DIVIDE THEN
-    DBMS_OUTPUT.PUT_LINE('Cannot divide by zero.');
-END;
-/
-
--- 53. Procedure with a function in a package
-CREATE OR REPLACE PACKAGE pkg_math AS
-  FUNCTION fn_add(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER;
-  FUNCTION fn_subtract(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER;
-END pkg_math;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_math AS
-  FUNCTION fn_add(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER AS
-  BEGIN
-    RETURN p_num1 + p_num2;
-  END fn_add;
-
-  FUNCTION fn_subtract(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER AS
-  BEGIN
-    RETURN p_num1 - p_num2;
-  END fn_subtract;
-END pkg_math;
-/
-CREATE OR REPLACE PROCEDURE sp_call_package_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(pkg_math.fn_add(10, 20));
-END;
-/
-
--- 54. Procedure with a private function in a package
-CREATE OR REPLACE PACKAGE pkg_private_function AS
-  PROCEDURE sp_public_proc;
-END pkg_private_function;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_private_function AS
-  FUNCTION fn_private_function RETURN VARCHAR2 AS
-  BEGIN
-    RETURN 'This is a private function.';
-  END fn_private_function;
-
-  PROCEDURE sp_public_proc AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE(fn_private_function);
-  END sp_public_proc;
-END pkg_private_function;
-/
-CREATE OR REPLACE PROCEDURE sp_call_private_function_proc AS
-BEGIN
-  pkg_private_function.sp_public_proc;
-END;
-/
-
--- 55. Procedure with a simple exception handler
-CREATE OR REPLACE PROCEDURE sp_simple_exception AS
-BEGIN
-  RAISE NO_DATA_FOUND;
-EXCEPTION
-  WHEN NO_DATA_FOUND THEN
-    DBMS_OUTPUT.PUT_LINE('No data found.');
-END;
-/
-
--- 56. Procedure with multiple exception handlers
-CREATE OR REPLACE PROCEDURE sp_multiple_exceptions AS
-BEGIN
-  IF SYSDATE > TO_DATE('2025-01-01', 'YYYY-MM-DD') THEN
-    RAISE NO_DATA_FOUND;
-  ELSE
-    RAISE TOO_MANY_ROWS;
-  END IF;
-EXCEPTION
-  WHEN NO_DATA_FOUND THEN
-    DBMS_OUTPUT.PUT_LINE('No data found.');
-  WHEN TOO_MANY_ROWS THEN
-    DBMS_OUTPUT.PUT_LINE('Too many rows.');
-END;
-/
-
--- 57. Procedure with a WHEN OTHERS exception handler
-CREATE OR REPLACE PROCEDURE sp_when_others_exception AS
-BEGIN
-  RAISE DUP_VAL_ON_INDEX;
-EXCEPTION
-  WHEN NO_DATA_FOUND THEN
-    DBMS_OUTPUT.PUT_LINE('No data found.');
-  WHEN OTHERS THEN
-    DBMS_OUTPUT.PUT_LINE('An unexpected error occurred.');
-END;
-/
-
--- 58. Procedure with a user-defined exception
-CREATE OR REPLACE PROCEDURE sp_user_defined_exception AS
-  e_my_exception EXCEPTION;
-BEGIN
-  RAISE e_my_exception;
-EXCEPTION
-  WHEN e_my_exception THEN
-    DBMS_OUTPUT.PUT_LINE('My custom exception was raised.');
-END;
-/
-
--- 59. Procedure with PRAGMA EXCEPTION_INIT
-CREATE OR REPLACE PROCEDURE sp_pragma_exception_init AS
-  e_deadlock EXCEPTION;
-  PRAGMA EXCEPTION_INIT(e_deadlock, -60);
-BEGIN
-  RAISE e_deadlock;
-EXCEPTION
-  WHEN e_deadlock THEN
-    DBMS_OUTPUT.PUT_LINE('A deadlock occurred.');
-END;
-/
-
--- 60. Procedure with RAISE_APPLICATION_ERROR
-CREATE OR REPLACE PROCEDURE sp_raise_application_error AS
-BEGIN
-  RAISE_APPLICATION_ERROR(-20001, 'This is a custom error message.');
-END;
-/
-
--- 61. Procedure with exception propagation
-CREATE OR REPLACE PROCEDURE sp_inner_proc_with_exception AS
-BEGIN
-  RAISE NO_DATA_FOUND;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_outer_proc_with_exception AS
-BEGIN
-  sp_inner_proc_with_exception;
-EXCEPTION
-  WHEN NO_DATA_FOUND THEN
-    DBMS_OUTPUT.PUT_LINE('Exception caught in outer procedure.');
-END;
-/
-
--- 62. Procedure with exception handling in a function
-CREATE OR REPLACE FUNCTION fn_exception_in_function RETURN NUMBER AS
-BEGIN
-  RAISE ZERO_DIVIDE;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_function_with_exception_handling AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_exception_in_function);
-EXCEPTION
-  WHEN ZERO_DIVIDE THEN
-    DBMS_OUTPUT.PUT_LINE('Exception from function caught in procedure.');
-END;
-/
-
--- 63. Procedure with SQLCODE and SQLERRM
-CREATE OR REPLACE PROCEDURE sp_sqlcode_sqlerrm AS
-BEGIN
-  RAISE DUP_VAL_ON_INDEX;
-EXCEPTION
-  WHEN OTHERS THEN
-    DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
-    DBMS_OUTPUT.PUT_LINE('Error message: ' || SQLERRM);
-END;
-/
-
--- 64. Procedure with a package specification
-CREATE OR REPLACE PACKAGE pkg_simple AS
-  PROCEDURE sp_hello;
-END pkg_simple;
-/
-
--- 65. Procedure with a package body
-CREATE OR REPLACE PACKAGE BODY pkg_simple AS
-  PROCEDURE sp_hello AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('Hello from a package!');
-  END sp_hello;
-END pkg_simple;
-/
-
--- 66. Procedure calling a package procedure
-CREATE OR REPLACE PROCEDURE sp_call_package_proc AS
-BEGIN
-  pkg_simple.sp_hello;
-END;
-/
-
--- 67. Package with a public variable
-CREATE OR REPLACE PACKAGE pkg_public_variable AS
-  g_public_variable VARCHAR2(100) := 'This is a public variable.';
-END pkg_public_variable;
-/
-CREATE OR REPLACE PROCEDURE sp_access_public_variable AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(pkg_public_variable.g_public_variable);
-END;
-/
-
--- 68. Package with a private variable
-CREATE OR REPLACE PACKAGE pkg_private_variable AS
-  PROCEDURE sp_show_private_variable;
-END pkg_private_variable;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_private_variable AS
-  g_private_variable VARCHAR2(100) := 'This is a private variable.';
-
-  PROCEDURE sp_show_private_variable AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE(g_private_variable);
-  END sp_show_private_variable;
-END pkg_private_variable;
-/
-CREATE OR REPLACE PROCEDURE sp_access_private_variable AS
-BEGIN
-  pkg_private_variable.sp_show_private_variable;
-END;
-/
-
--- 69. Package with overloaded procedures
-CREATE OR REPLACE PACKAGE pkg_overloading AS
-  PROCEDURE sp_overloaded(p_param IN NUMBER);
-  PROCEDURE sp_overloaded(p_param IN VARCHAR2);
-END pkg_overloading;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_overloading AS
-  PROCEDURE sp_overloaded(p_param IN NUMBER) AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('Number: ' || p_param);
-  END sp_overloaded;
-
-  PROCEDURE sp_overloaded(p_param IN VARCHAR2) AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('String: ' || p_param);
-  END sp_overloaded;
-END pkg_overloading;
-/
-CREATE OR REPLACE PROCEDURE sp_call_overloaded_proc AS
-BEGIN
-  pkg_overloading.sp_overloaded(123);
-  pkg_overloading.sp_overloaded('abc');
-END;
-/
-
--- 70. Package with a forward declaration
-CREATE OR REPLACE PACKAGE pkg_forward_declaration AS
-  PROCEDURE sp_proc1;
-  PROCEDURE sp_proc2;
-END pkg_forward_declaration;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_forward_declaration AS
-  PROCEDURE sp_proc2; -- Forward declaration
-
-  PROCEDURE sp_proc1 AS
-  BEGIN
-    sp_proc2;
-  END sp_proc1;
-
-  PROCEDURE sp_proc2 AS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('This is procedure 2.');
-  END sp_proc2;
-END pkg_forward_declaration;
-/
-
--- 71. Package with an initialization block
-CREATE OR REPLACE PACKAGE pkg_initialization AS
-  g_initialized_variable VARCHAR2(100);
-END pkg_initialization;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_initialization AS
-BEGIN
-  g_initialized_variable := 'This variable was initialized in the package body.';
-END pkg_initialization;
-/
-CREATE OR REPLACE PROCEDURE sp_access_initialized_variable AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(pkg_initialization.g_initialized_variable);
-END;
-/
-
--- 72. Package with a cursor
-CREATE OR REPLACE PACKAGE pkg_cursor AS
-  CURSOR c_depts IS SELECT department_name FROM departments;
-  PROCEDURE sp_show_departments;
-END pkg_cursor;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_cursor AS
-  PROCEDURE sp_show_departments AS
-  BEGIN
-    FOR dept_rec IN c_depts LOOP
-      DBMS_OUTPUT.PUT_LINE(dept_rec.department_name);
-    END LOOP;
-  END sp_show_departments;
-END pkg_cursor;
-/
-
--- 73. Package with a record type
-CREATE OR REPLACE PACKAGE pkg_record AS
-  TYPE r_employee IS RECORD (
-    name employees.employee_name%TYPE,
-    salary employees.salary%TYPE
-  );
-  PROCEDURE sp_show_employee(p_emp_id NUMBER);
-END pkg_record;
-/
-CREATE OR REPLACE PACKAGE BODY pkg_record AS
-  PROCEDURE sp_show_employee(p_emp_id NUMBER) AS
-    v_employee r_employee;
-  BEGIN
-    SELECT employee_name, salary INTO v_employee FROM employees WHERE employee_id = p_emp_id;
-    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.name || ', Salary: ' || v_employee.salary);
-  END sp_show_employee;
-END pkg_record;
-/
-
--- 74. Procedure with an autonomous transaction
-CREATE OR REPLACE PROCEDURE sp_log_action(p_action VARCHAR2) AS
-  PRAGMA AUTONOMOUS_TRANSACTION;
-BEGIN
-  INSERT INTO action_log (action, action_date) VALUES (p_action, SYSDATE);
-  COMMIT;
-END;
-/
-
--- 75. Procedure calling an autonomous transaction procedure
-CREATE OR REPLACE PROCEDURE sp_main_transaction AS
-BEGIN
-  sp_log_action('Starting main transaction.');
-  -- Main transaction logic here
-  sp_log_action('Ending main transaction.');
-  COMMIT;
-END;
-/
-
--- 76. Procedure with dynamic SQL to create a table
-CREATE OR REPLACE PROCEDURE sp_create_temp_table AS
-BEGIN
-  EXECUTE IMMEDIATE 'CREATE TABLE temp_table (id NUMBER, data VARCHAR2(100))';
-END;
-/
-
--- 77. Procedure with dynamic SQL to insert data
-CREATE OR REPLACE PROCEDURE sp_insert_into_temp_table(p_id NUMBER, p_data VARCHAR2) AS
-BEGIN
-  EXECUTE IMMEDIATE 'INSERT INTO temp_table (id, data) VALUES (:1, :2)' USING p_id, p_data;
-END;
-/
-
--- 78. Procedure with dynamic SQL to query data
-CREATE OR REPLACE PROCEDURE sp_query_temp_table AS
-  TYPE t_cursor IS REF CURSOR;
-  c_data t_cursor;
-  v_id NUMBER;
-  v_data VARCHAR2(100);
-BEGIN
-  OPEN c_data FOR 'SELECT id, data FROM temp_table';
-  LOOP
-    FETCH c_data INTO v_id, v_data;
-    EXIT WHEN c_data%NOTFOUND;
-    DBMS_OUTPUT.PUT_LINE('ID: ' || v_id || ', Data: ' || v_data);
-  END LOOP;
-  CLOSE c_data;
-END;
-/
-
--- 79. Procedure with dynamic SQL and BULK COLLECT
-CREATE OR REPLACE PROCEDURE sp_bulk_collect_dynamic AS
-  TYPE t_ids IS TABLE OF NUMBER;
-  v_ids t_ids;
-BEGIN
-  EXECUTE IMMEDIATE 'SELECT id FROM temp_table' BULK COLLECT INTO v_ids;
-  FOR i IN 1..v_ids.COUNT LOOP
-    DBMS_OUTPUT.PUT_LINE('ID: ' || v_ids(i));
-  END LOOP;
-END;
-/
-
--- 80. Procedure with DBMS_SQL package
-CREATE OR REPLACE PROCEDURE sp_dbms_sql_example AS
-  v_cursor INTEGER;
-  v_rows INTEGER;
-BEGIN
-  v_cursor := DBMS_SQL.OPEN_CURSOR;
-  DBMS_SQL.PARSE(v_cursor, 'SELECT * FROM employees', DBMS_SQL.NATIVE);
-  v_rows := DBMS_SQL.EXECUTE(v_cursor);
-  DBMS_SQL.CLOSE_CURSOR(v_cursor);
-END;
-/
-
--- 81. Procedure with a pipelined function
-CREATE OR REPLACE TYPE t_number_row AS OBJECT (n NUMBER);
-/
-CREATE OR REPLACE TYPE t_number_table AS TABLE OF t_number_row;
-/
-CREATE OR REPLACE FUNCTION fn_pipelined_numbers(p_count NUMBER) RETURN t_number_table PIPELINED AS
-BEGIN
-  FOR i IN 1..p_count LOOP
-    PIPE ROW(t_number_row(i));
-  END LOOP;
-  RETURN;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_pipelined_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_pipelined_numbers(5))) LOOP
-    DBMS_OUTPUT.PUT_LINE(rec.n);
-  END LOOP;
-END;
-/
-
--- 82. Procedure with a table function
-CREATE OR REPLACE FUNCTION fn_table_function(p_count NUMBER) RETURN t_number_table AS
-  v_table t_number_table := t_number_table();
-BEGIN
-  FOR i IN 1..p_count LOOP
-    v_table.EXTEND;
-    v_table(v_table.LAST) := t_number_row(i);
-  END LOOP;
-  RETURN v_table;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_table_function AS
-BEGIN
-  FOR rec IN (SELECT * FROM TABLE(fn_table_function(5))) LOOP
-    DBMS_OUTPUT.PUT_LINE(rec.n);
-  END LOOP;
-END;
-/
-
--- 83. Procedure with a deterministic function
-CREATE OR REPLACE FUNCTION fn_deterministic_add(p_num1 NUMBER, p_num2 NUMBER) RETURN NUMBER DETERMINISTIC AS
-BEGIN
-  RETURN p_num1 + p_num2;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_deterministic_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_deterministic_add(10, 20));
-END;
-/
-
--- 84. Procedure with a result cache function
-CREATE OR REPLACE FUNCTION fn_result_cache_function(p_param NUMBER) RETURN NUMBER RESULT_CACHE AS
-BEGIN
-  -- Expensive calculation here
-  RETURN p_param * 2;
-END;
-/
-CREATE OR REPLACE PROCEDURE sp_call_result_cache_function AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE(fn_result_cache_function(10));
-  DBMS_OUTPUT.PUT_LINE(fn_result_cache_function(10)); -- This will be faster
-END;
-/
-
--- 85. Procedure with a collection type
-CREATE OR REPLACE PROCEDURE sp_collection_example AS
-  TYPE t_names IS TABLE OF VARCHAR2(100);
-  v_names t_names := t_names('John', 'Jane', 'Peter');
-BEGIN
-  FOR i IN 1..v_names.COUNT LOOP
-    DBMS_OUTPUT.PUT_LINE(v_names(i));
-  END LOOP;
-END;
-/
-
--- 86. Procedure with an associative array
-CREATE OR REPLACE PROCEDURE sp_associative_array_example AS
-  TYPE t_ages IS TABLE OF NUMBER INDEX BY VARCHAR2(100);
-  v_ages t_ages;
-BEGIN
-  v_ages('John') := 30;
-  v_ages('Jane') := 25;
-  DBMS_OUTPUT.PUT_LINE('John is ' || v_ages('John') || ' years old.');
-END;
-/
-
--- 87. Procedure with a nested table
-CREATE OR REPLACE PROCEDURE sp_nested_table_example AS
-  TYPE t_numbers IS TABLE OF NUMBER;
-  v_numbers t_numbers := t_numbers(1, 2, 3, 4, 5);
-BEGIN
-  FOR i IN 1..v_numbers.COUNT LOOP
-    DBMS_OUTPUT.PUT_LINE(v_numbers(i));
-  END LOOP;
-END;
-/
-
--- 88. Procedure with a varray
-CREATE OR REPLACE PROCEDURE sp_varray_example AS
-  TYPE t_colors IS VARRAY(3) OF VARCHAR2(20);
-  v_colors t_colors := t_colors('Red', 'Green', 'Blue');
-BEGIN
-  FOR i IN 1..v_colors.COUNT LOOP
-    DBMS_OUTPUT.PUT_LINE(v_colors(i));
-  END LOOP;
-END;
-/
-
--- 89. Procedure with a record type
-CREATE OR REPLACE PROCEDURE sp_record_example AS
-  TYPE r_person IS RECORD (
-    name VARCHAR2(100),
-    age NUMBER
-  );
-  v_person r_person;
-BEGIN
-  v_person.name := 'John';
-  v_person.age := 30;
-  DBMS_OUTPUT.PUT_LINE('Name: ' || v_person.name || ', Age: ' || v_person.age);
-END;
-/
-
--- 90. Procedure with %TYPE attribute
-CREATE OR REPLACE PROCEDURE sp_percent_type_example AS
-  v_emp_name employees.employee_name%TYPE;
-BEGIN
-  SELECT employee_name INTO v_emp_name FROM employees WHERE employee_id = 100;
-  DBMS_OUTPUT.PUT_LINE(v_emp_name);
-END;
-/
-
--- 91. Procedure with %ROWTYPE attribute
-CREATE OR REPLACE PROCEDURE sp_percent_rowtype_example AS
-  v_employee employees%ROWTYPE;
-BEGIN
-  SELECT * INTO v_employee FROM employees WHERE employee_id = 100;
-  DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.employee_name || ', Salary: ' || v_employee.salary);
-END;
-/
-
--- 92. Procedure with a simple trigger
-CREATE OR REPLACE TRIGGER trg_before_insert_employee
-BEFORE INSERT ON employees
-FOR EACH ROW
-BEGIN
-  :new.salary := :new.salary + 100;
-END;
-/
-
--- 93. Procedure with a compound trigger
-CREATE OR REPLACE TRIGGER trg_compound_employee
-FOR INSERT ON employees
-COMPOUND TRIGGER
-  BEFORE STATEMENT IS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('Before statement');
-  END BEFORE STATEMENT;
-
-  BEFORE EACH ROW IS
-  BEGIN
-    :new.salary := :new.salary + 100;
-  END BEFORE EACH ROW;
-
-  AFTER EACH ROW IS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('After each row');
-  END AFTER EACH ROW;
-
-  AFTER STATEMENT IS
-  BEGIN
-    DBMS_OUTPUT.PUT_LINE('After statement');
-  END AFTER STATEMENT;
-END trg_compound_employee;
-/
-
--- 94. Procedure with a DDL trigger
-CREATE OR REPLACE TRIGGER trg_ddl_audit
-AFTER DDL ON SCHEMA
-BEGIN
-  INSERT INTO ddl_log (event, object_name, object_type, owner)
-  VALUES (ora_sysevent, ora_dict_obj_name, ora_dict_obj_type, ora_dict_obj_owner);
-END;
-/
-
--- 95. Procedure with a database event trigger
-CREATE OR REPLACE TRIGGER trg_logon
-AFTER LOGON ON DATABASE
-BEGIN
-  INSERT INTO logon_log (username, logon_time)
-  VALUES (USER, SYSDATE);
-END;
-/
-
--- 96. Procedure with a materialized view
-CREATE MATERIALIZED VIEW mv_employee_summary
-AS SELECT d.department_name, COUNT(e.employee_id) AS num_employees
-   FROM departments d
-   JOIN employees e ON d.department_id = e.department_id
-   GROUP BY d.department_name;
-
--- 97. Procedure with a sequence
-CREATE SEQUENCE seq_employee_id START WITH 207 INCREMENT BY 1;
-
--- 98. Procedure with a synonym
-CREATE SYNONYM emp FOR employees;
-
--- 99. Procedure with a view
-CREATE OR REPLACE VIEW v_employee_details AS
-SELECT e.employee_name, d.department_name, j.job_title
-FROM employees e
-JOIN departments d ON e.department_id = d.department_id
-JOIN jobs j ON e.job_id = j.job_id;
-
--- 100. Procedure with a hierarchical query
-CREATE OR REPLACE PROCEDURE sp_hierarchical_query AS
-BEGIN
-  FOR rec IN (
-    SELECT level, employee_name
-    FROM employees
-    START WITH manager_id IS NULL
-    CONNECT BY PRIOR employee_id = manager_id
-  ) LOOP
-    DBMS_OUTPUT.PUT_LINE(LPAD(' ', (rec.level - 1) * 2) || rec.employee_name);
-  END LOOP;
-END;
-/
-
--- 101. Procedure with a PIVOT query
-CREATE OR REPLACE PROCEDURE sp_pivot_query AS
-BEGIN
-  FOR rec IN (
-    SELECT *
-    FROM (
-      SELECT department_name, job_title
-      FROM employees e
-      JOIN departments d ON e.department_id = d.department_id
-      JOIN jobs j ON e.job_id = j.job_id
-    )
-    PIVOT (
-      COUNT(job_title)
-      FOR job_title IN ('Programmer' AS prog, 'Accountant' AS acct)
-    )
-  ) LOOP
-    DBMS_OUTPUT.PUT_LINE(rec.department_name || ' - Programmers: ' || rec.prog || ', Accountants: ' || rec.acct);
-  END LOOP;
-END;
-/
diff --git a/sql-assests/psql-university-schema.sql b/sql-assests/psql-university-schema.sql
deleted file mode 100644
index 03942ce..0000000
--- a/sql-assests/psql-university-schema.sql
+++ /dev/null
@@ -1,253 +0,0 @@
--- Comprehensive PostgreSQL University Database Schema
--- Author: Gemini AI
--- Date: 2025-09-22
-
--- Enable pgcrypto for UUID generation
-CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-
--- Drop existing objects to start fresh
-DROP TABLE IF EXISTS grades, enrollments, students, courses, professors, departments CASCADE;
-DROP FUNCTION IF EXISTS calculate_gpa(UUID);
-DROP PROCEDURE IF EXISTS enroll_student(UUID, UUID);
-
--- Departments Table
-CREATE TABLE departments (
-    department_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    department_name VARCHAR(255) NOT NULL UNIQUE,
-    department_head VARCHAR(255),
-    building VARCHAR(100),
-    budget NUMERIC(12, 2) CHECK (budget > 0),
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW()
-);
-
--- Professors Table
-CREATE TABLE professors (
-    professor_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    first_name VARCHAR(100) NOT NULL,
-    last_name VARCHAR(100) NOT NULL,
-    email VARCHAR(255) NOT NULL UNIQUE,
-    phone_number VARCHAR(20),
-    office_location VARCHAR(100),
-    department_id UUID NOT NULL,
-    hire_date DATE,
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW(),
-    FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE SET NULL
-);
-
--- Courses Table
-CREATE TABLE courses (
-    course_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    course_code VARCHAR(20) NOT NULL UNIQUE,
-    course_title VARCHAR(255) NOT NULL,
-    course_description TEXT,
-    credits INT NOT NULL CHECK (credits > 0),
-    department_id UUID NOT NULL,
-    professor_id UUID,
-    semester VARCHAR(50),
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW(),
-    FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE CASCADE,
-    FOREIGN KEY (professor_id) REFERENCES professors(professor_id) ON DELETE SET NULL
-);
-
--- Students Table
-CREATE TABLE students (
-    student_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    first_name VARCHAR(100) NOT NULL,
-    last_name VARCHAR(100) NOT NULL,
-    email VARCHAR(255) NOT NULL UNIQUE,
-    date_of_birth DATE,
-    major VARCHAR(100),
-    enrollment_date DATE,
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW()
-);
-
--- Enrollments Table
-CREATE TABLE enrollments (
-    enrollment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    student_id UUID NOT NULL,
-    course_id UUID NOT NULL,
-    enrollment_date DATE DEFAULT NOW(),
-    grade CHAR(2),
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW(),
-    UNIQUE (student_id, course_id),
-    FOREIGN KEY (student_id) REFERENCES students(student_id) ON DELETE CASCADE,
-    FOREIGN KEY (course_id) REFERENCES courses(course_id) ON DELETE CASCADE
-);
-
--- Grades Table (Alternative to grade in enrollments, for more detail)
-CREATE TABLE grades (
-    grade_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
-    enrollment_id UUID NOT NULL,
-    grade_value NUMERIC(5, 2) NOT NULL, -- e.g., 95.5
-    grade_letter VARCHAR(2) NOT NULL, -- e.g., A+, B, C-
-    comments TEXT,
-    created_at TIMESTAMPTZ DEFAULT NOW(),
-    updated_at TIMESTAMPTZ DEFAULT NOW(),
-    FOREIGN KEY (enrollment_id) REFERENCES enrollments(enrollment_id) ON DELETE CASCADE
-);
-
--- Indexes for performance
-CREATE INDEX idx_professors_department_id ON professors(department_id);
-CREATE INDEX idx_courses_department_id ON courses(department_id);
-CREATE INDEX idx_courses_professor_id ON courses(professor_id);
-CREATE INDEX idx_enrollments_student_id ON enrollments(student_id);
-CREATE INDEX idx_enrollments_course_id ON enrollments(course_id);
-CREATE INDEX idx_grades_enrollment_id ON grades(enrollment_id);
-CREATE INDEX idx_students_email ON students(email);
-CREATE INDEX idx_professors_email ON professors(email);
-
--- Stored Procedure to enroll a student in a course
-CREATE OR REPLACE PROCEDURE enroll_student(
-    p_student_id UUID,
-    p_course_id UUID
-)
-LANGUAGE plpgsql
-AS $$
-BEGIN
-    -- Check if the student and course exist
-    IF NOT EXISTS (SELECT 1 FROM students WHERE student_id = p_student_id) THEN
-        RAISE EXCEPTION 'Student with ID % does not exist', p_student_id;
-    END IF;
-
-    IF NOT EXISTS (SELECT 1 FROM courses WHERE course_id = p_course_id) THEN
-        RAISE EXCEPTION 'Course with ID % does not exist', p_course_id;
-    END IF;
-
-    -- Check if the student is already enrolled
-    IF EXISTS (SELECT 1 FROM enrollments WHERE student_id = p_student_id AND course_id = p_course_id) THEN
-        RAISE NOTICE 'Student % is already enrolled in course %', p_student_id, p_course_id;
-        RETURN;
-    END IF;
-
-    -- Insert the new enrollment
-    INSERT INTO enrollments (student_id, course_id)
-    VALUES (p_student_id, p_course_id);
-
-    RAISE NOTICE 'Student % successfully enrolled in course %', p_student_id, p_course_id;
-END;
-$$;
-
--- Function to calculate a student's GPA
-CREATE OR REPLACE FUNCTION calculate_gpa(
-    p_student_id UUID
-)
-RETURNS NUMERIC
-LANGUAGE plpgsql
-AS $$
-DECLARE
-    total_points NUMERIC := 0;
-    total_credits INT := 0;
-    gpa NUMERIC := 0.0;
-    enrollment_record RECORD;
-    grade_points NUMERIC;
-BEGIN
-    -- Check if the student exists
-    IF NOT EXISTS (SELECT 1 FROM students WHERE student_id = p_student_id) THEN
-        RAISE EXCEPTION 'Student with ID % does not exist', p_student_id;
-    END IF;
-
-    FOR enrollment_record IN
-        SELECT e.grade, c.credits
-        FROM enrollments e
-        JOIN courses c ON e.course_id = c.course_id
-        WHERE e.student_id = p_student_id AND e.grade IS NOT NULL
-    LOOP
-        grade_points := CASE enrollment_record.grade
-            WHEN 'A+' THEN 4.0
-            WHEN 'A'  THEN 4.0
-            WHEN 'A-' THEN 3.7
-            WHEN 'B+' THEN 3.3
-            WHEN 'B'  THEN 3.0
-            WHEN 'B-' THEN 2.7
-            WHEN 'C+' THEN 2.3
-            WHEN 'C'  THEN 2.0
-            WHEN 'C-' THEN 1.7
-            WHEN 'D+' THEN 1.3
-            WHEN 'D'  THEN 1.0
-            WHEN 'F'  THEN 0.0
-            ELSE 0.0
-        END CASE;
-
-        total_points := total_points + (grade_points * enrollment_record.credits);
-        total_credits := total_credits + enrollment_record.credits;
-    END LOOP;
-
-    IF total_credits > 0 THEN
-        gpa := total_points / total_credits;
-    END IF;
-
-    RETURN ROUND(gpa, 2);
-END;
-$$;
-
--- Sample Data Insertion
-
--- Departments
-INSERT INTO departments (department_name, department_head, building, budget) VALUES
-('Computer Science', 'Dr. Alan Turing', 'Building A', 500000.00),
-('Mathematics', 'Dr. Ada Lovelace', 'Building B', 450000.00),
-('Physics', 'Dr. Marie Curie', 'Building C', 600000.00);
-
--- Professors
-DO $$
-DECLARE
-    cs_dept_id UUID := (SELECT department_id FROM departments WHERE department_name = 'Computer Science');
-    math_dept_id UUID := (SELECT department_id FROM departments WHERE department_name = 'Mathematics');
-BEGIN
-    INSERT INTO professors (first_name, last_name, email, department_id, hire_date) VALUES
-    ('John', 'Doe', 'john.doe@university.edu', cs_dept_id, '2020-08-15'),
-    ('Jane', 'Smith', 'jane.smith@university.edu', math_dept_id, '2018-01-10');
-END $$;
-
--- Students
-INSERT INTO students (first_name, last_name, email, major, enrollment_date) VALUES
-('Alice', 'Johnson', 'alice.j@university.edu', 'Computer Science', '2022-09-01'),
-('Bob', 'Williams', 'bob.w@university.edu', 'Mathematics', '2021-09-01');
-
--- Courses
-DO $$
-DECLARE
-    cs_dept_id UUID := (SELECT department_id FROM departments WHERE department_name = 'Computer Science');
-    math_dept_id UUID := (SELECT department_id FROM departments WHERE department_name = 'Mathematics');
-    prof_doe_id UUID := (SELECT professor_id FROM professors WHERE email = 'john.doe@university.edu');
-BEGIN
-    INSERT INTO courses (course_code, course_title, credits, department_id, professor_id, semester) VALUES
-    ('CS101', 'Introduction to Programming', 3, cs_dept_id, prof_doe_id, 'Fall 2024'),
-    ('MATH201', 'Calculus III', 4, math_dept_id, NULL, 'Fall 2024');
-END $$;
-
--- Enroll students using the stored procedure
-DO $$
-DECLARE
-    student_alice_id UUID := (SELECT student_id FROM students WHERE email = 'alice.j@university.edu');
-    course_cs101_id UUID := (SELECT course_id FROM courses WHERE course_code = 'CS101');
-BEGIN
-    CALL enroll_student(student_alice_id, course_cs101_id);
-END $$;
-
--- Update enrollment with a grade
-DO $$
-DECLARE
-    enrollment_id_val UUID;
-BEGIN
-    SELECT enrollment_id INTO enrollment_id_val
-    FROM enrollments e
-    JOIN students s ON e.student_id = s.student_id
-    JOIN courses c ON e.course_id = c.course_id
-    WHERE s.email = 'alice.j@university.edu' AND c.course_code = 'CS101';
-
-    UPDATE enrollments SET grade = 'A' WHERE enrollment_id = enrollment_id_val;
-
-    INSERT INTO grades (enrollment_id, grade_value, grade_letter)
-    VALUES (enrollment_id_val, 92.5, 'A');
-END $$;
-
--- Verify GPA calculation
-SELECT calculate_gpa((SELECT student_id FROM students WHERE email = 'alice.j@university.edu')) AS alice_gpa;
-
--- End of schema
diff --git a/sql-assests/sample.sql b/sql-assests/sample.sql
deleted file mode 100644
index 1a857c8..0000000
--- a/sql-assests/sample.sql
+++ /dev/null
@@ -1,10 +0,0 @@
-CREATE OR REPLACE PROCEDURE get_employee_name (
-    p_employee_id IN employees.employee_id%TYPE,
-    p_first_name OUT employees.first_name%TYPE
-) AS
-BEGIN
-    SELECT first_name
-    INTO p_first_name
-    FROM employees
-    WHERE employee_id = p_employee_id;
-END;
diff --git a/sql-assests/table-dll.sql b/sql-assests/table-dll.sql
deleted file mode 100644
index bffb597..0000000
--- a/sql-assests/table-dll.sql
+++ /dev/null
@@ -1,78 +0,0 @@
--- Core Tables
-CREATE TABLE AIRPLANES (
-    airplane_serial_number VARCHAR2(50) PRIMARY KEY,
-    model VARCHAR2(100) NOT NULL,
-    manufacturer VARCHAR2(100) NOT NULL,
-    capacity NUMBER NOT NULL
-);
-
-CREATE TABLE AIRPORTS (
-    airport_code VARCHAR2(10) PRIMARY KEY,
-    name VARCHAR2(100) NOT NULL,
-    city VARCHAR2(100) NOT NULL,
-    country VARCHAR2(100) NOT NULL
-);
-
-CREATE TABLE FLIGHTS (
-    flight_number VARCHAR2(20) PRIMARY KEY,
-    departure_airport_code VARCHAR2(10) NOT NULL,
-    arrival_airport_code VARCHAR2(10) NOT NULL,
-    departure_datetime TIMESTAMP NOT NULL,
-    arrival_datetime TIMESTAMP NOT NULL,
-    airplane_serial_number VARCHAR2(50) NOT NULL,
-    CONSTRAINT fk_departure_airport FOREIGN KEY (departure_airport_code) REFERENCES AIRPORTS(airport_code),
-    CONSTRAINT fk_arrival_airport FOREIGN KEY (arrival_airport_code) REFERENCES AIRPORTS(airport_code),
-    CONSTRAINT fk_airplane FOREIGN KEY (airplane_serial_number) REFERENCES AIRPLANES(airplane_serial_number)
-);
-
-CREATE TABLE PASSENGERS (
-    passenger_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    first_name VARCHAR2(100) NOT NULL,
-    last_name VARCHAR2(100) NOT NULL,
-    email VARCHAR2(100) UNIQUE,
-    phone_number VARCHAR2(20)
-);
-
--- Reservation and Ticketing Tables
-CREATE TABLE RESERVATIONS (
-    reservation_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    passenger_id NUMBER NOT NULL,
-    flight_number VARCHAR2(20) NOT NULL,
-    seat_number VARCHAR2(10),
-    reservation_status VARCHAR2(20) NOT NULL CHECK (reservation_status IN ('CONFIRMED', 'CANCELED', 'PENDING')),
-    CONSTRAINT fk_passenger FOREIGN KEY (passenger_id) REFERENCES PASSENGERS(passenger_id),
-    CONSTRAINT fk_flight FOREIGN KEY (flight_number) REFERENCES FLIGHTS(flight_number)
-);
-
-CREATE TABLE TICKETS (
-    ticket_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    reservation_id NUMBER NOT NULL,
-    price NUMBER(10, 2) NOT NULL,
-    issuance_date DATE NOT NULL,
-    CONSTRAINT fk_reservation FOREIGN KEY (reservation_id) REFERENCES RESERVATIONS(reservation_id)
-);
-
--- Operational Tables
-CREATE TABLE CREW_MEMBERS (
-    crew_member_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    first_name VARCHAR2(100) NOT NULL,
-    last_name VARCHAR2(100) NOT NULL,
-    role VARCHAR2(50) NOT NULL CHECK (role IN ('PILOT', 'CO-PILOT', 'FLIGHT_ATTENDANT', 'CABIN_CREW'))
-);
-
-CREATE TABLE CREW_ASSIGNMENTS (
-    assignment_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    flight_number VARCHAR2(20) NOT NULL,
-    crew_member_id NUMBER NOT NULL,
-    CONSTRAINT fk_flight_assignment FOREIGN KEY (flight_number) REFERENCES FLIGHTS(flight_number),
-    CONSTRAINT fk_crew_member FOREIGN KEY (crew_member_id) REFERENCES CREW_MEMBERS(crew_member_id)
-);
-
-CREATE TABLE AIRCRAFT_MAINTENANCE (
-    maintenance_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
-    airplane_serial_number VARCHAR2(50) NOT NULL,
-    maintenance_date DATE NOT NULL,
-    description VARCHAR2(500) NOT NULL,
-    technician_id VARCHAR2(50),
-    CONSTRAINT fk_airplane_maintenance FOREIGN KEY (airplane_serial_number) REFERENCES AIRPLANES(airplane_serial_number)
-);
diff --git a/sql-assests/test.sql b/sql-assests/test.sql
deleted file mode 100644
index 09c2a7e..0000000
--- a/sql-assests/test.sql
+++ /dev/null
@@ -1,34 +0,0 @@
-CREATE TABLE products
-(
-  product_id           INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
-  product_name         VARCHAR2(255 CHAR) NOT NULL,
-  unit_price           NUMBER(10,2),
-  product_details      BLOB,
-  product_image        BLOB,
-  image_mime_type      VARCHAR2(512 CHAR),
-  image_filename       VARCHAR2(512 CHAR),
-  image_charset        VARCHAR2(512 CHAR),
-  image_last_updated   DATE
-);
-
-
-CREATE OR REPLACE PROCEDURE EMP_SAL_RAISE
-(P_EMP_ID IN NUMBER, SAL_RAISE IN NUMBER)
-AS
-V_EMP_CURRENT_SAL NUMBER;
-BEGIN
-SELECT SALARY INTO V_EMP_CURRENT_SAL FROM EMPLOYEES WHERE EMPLOYEE_ID=P_EMP_ID;
-UPDATE EMPLOYEES
-SET SALARY=V_EMP_CURRENT_SAL+SAL_RAISE
-WHERE EMPLOYEE_ID=P_EMP_ID;
-DBMS_OUTPUT.PUT_LINE('New Salary For Employee ID: '||P_EMP_ID||' Is '||(V_EMP_CURRENT_
-SAL+SAL_RAISE));
-EXCEPTION WHEN OTHERS THEN
-RAISE_APPLICATION_ERROR(-20001,'An error was encountered
-'||SQLCODE||' -ERROR-
-'||SQLERRM);
-ROLLBACK;
-COMMIT;
-END;
-/
-
diff --git a/sql-assests/test_queries.sql b/sql-assests/test_queries.sql
deleted file mode 100644
index 6744527..0000000
--- a/sql-assests/test_queries.sql
+++ /dev/null
@@ -1,27 +0,0 @@
--- Stored Procedure 1
-CREATE OR REPLACE PROCEDURE sp_test1 AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Test 1');
-END;
-/
-
--- Stored Procedure 2
-CREATE OR REPLACE PROCEDURE sp_test2 AS
-BEGIN
-  DBMS_OUTPUT.PUT_LINE('Test 2');
-END;
-/
-
--- DDL 1
-CREATE TABLE test_table1 (
-  id NUMBER PRIMARY KEY,
-  name VARCHAR2(100)
-);
-/
-
--- DDL 2
-CREATE TABLE test_table2 (
-  id NUMBER PRIMARY KEY,
-  description VARCHAR2(255)
-);
-/
\ No newline at end of file
diff --git a/worker.py b/worker.py
index 4858d81..8bbdfd5 100644
--- a/worker.py
+++ b/worker.py
@@ -10,7 +10,6 @@ import sys
 import os
 import psycopg2
 import oracledb
-import redis
 import uuid
 import sqlparse
 from typing import Optional
@@ -18,7 +17,7 @@ from typing import Optional
 sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '.')))
 
 WORKER_ID = str(uuid.uuid4())[:8]
-from api import database, queues, ai_converter
+from api import database, queues, ai_converter, migration_db, schema_comparer
 
 # --- Existing SQL Conversion Feature ---
 
@@ -84,20 +83,8 @@ def callback(ch, method, properties, body):
 
 # --- New Data Migration Feature ---
 
-DATA_MIGRATION_DLX = 'data_migration_dlx'
-DATA_MIGRATION_DLQ = 'data_migration_dlq'
-DATA_MIGRATION_QUEUE = 'data_migration_jobs'
 CHUNK_SIZE = 1000
 
-def get_redis_connection():
-    """Establishes a connection to Redis."""
-    return redis.Redis(
-        host=os.getenv("REDIS_HOST", "localhost"),
-        port=int(os.getenv("REDIS_PORT", 6379)),
-        db=0,
-        decode_responses=True
-    )
-
 def get_oracle_connection(user, password, host, port, service_name):
     """Establishes a connection to the Oracle database."""
     dsn = oracledb.makedsn(host, port, service_name=service_name)
@@ -105,75 +92,118 @@ def get_oracle_connection(user, password, host, port, service_name):
 
 def data_migration_callback(ch, method, properties, body):
     database.initialize_db_pool()
-    task_info = json.loads(body)
-    task_id = task_info['task_id']
-    
-    redis_conn = get_redis_connection()
-    
-    def update_status(status, message, progress=None):
-        status_data = {"status": status, "message": message, "progress": progress}
-        redis_conn.set(f"migration_status:{task_id}", json.dumps(status_data))
+    job_message = json.loads(body)
+    job_id = job_message['job_id']
 
     try:
-        print(f" [x] Received data migration task {task_id}")
-        update_status("running", "Task received, starting migration.")
+        print(f" [x] Received data migration job {job_id} (producer)")
+        migration_job = migration_db.get_migration_job(job_id)
+        if not migration_job:
+            raise ValueError(f"Migration job {job_id} not found in database.")
+
+        migration_db.update_migration_job_status(job_id, "RUNNING")
 
         # Oracle Connection
-        ora_creds = task_info['oracle_credentials']
+        ora_creds_dict = json.loads(migration_job.source_connection_string)
         ora_conn = get_oracle_connection(
-            ora_creds['user'], ora_creds['password'], ora_creds['host'],
-            ora_creds['port'], ora_creds['service_name']
+            ora_creds_dict['user'], ora_creds_dict['password'], ora_creds_dict['host'],
+            ora_creds_dict['port'], ora_creds_dict['service_name'] or ora_creds_dict['sid']
         )
         ora_cursor = ora_conn.cursor()
 
-        # Postgres Connection
-        pg_creds = task_info['postgres_credentials']
-        pg_conn = psycopg2.connect(
-            dbname=pg_creds['dbname'], user=pg_creds['user'], password=pg_creds['password'],
-            host=pg_creds['host'], port=pg_creds['port']
-        )
-        pg_cursor = pg_conn.cursor()
-
-        source_table = task_info['source_table']
-        dest_table = task_info['destination_table']
+        source_table = migration_job.source_table_name
+        
+        # Get column names for dynamic insert
+        ora_cursor.execute(f"SELECT * FROM {source_table} WHERE ROWNUM = 0")
+        column_names = [col[0] for col in ora_cursor.description]
 
         ora_cursor.execute(f"SELECT COUNT(*) FROM {source_table}")
         total_rows = ora_cursor.fetchone()[0]
-        update_status("running", f"Found {total_rows} rows to migrate.")
+        migration_db.update_migration_job_status(job_id, "RUNNING", total_rows=total_rows)
+        print(f" [x] Job {job_id}: Found {total_rows} rows to migrate from {source_table}.")
 
         ora_cursor.execute(f"SELECT * FROM {source_table}")
         
-        rows_migrated = 0
+        rows_processed = 0
         while True:
             chunk = ora_cursor.fetchmany(CHUNK_SIZE)
             if not chunk:
                 break
             
-            # This is a simplified insert. For production, you'd need column mapping.
-            placeholders = ", ".join(['%s'] * len(chunk[0]))
-            insert_query = f"INSERT INTO {dest_table} VALUES ({placeholders})"
-            
-            pg_cursor.executemany(insert_query, chunk)
-            pg_conn.commit()
+            for row_data in chunk:
+                row_message = {
+                    "job_id": str(job_id),
+                    "row_data": list(row_data), # Convert tuple to list for JSON serialization
+                    "column_names": column_names
+                }
+                queues.get_rabbitmq_connection().channel().basic_publish(
+                    exchange='',
+                    routing_key=queues.QUEUE_CONFIG['DATA_MIGRATION_ROW']['queue'],
+                    body=json.dumps(row_message),
+                    properties=pika.BasicProperties(delivery_mode=2)
+                )
+                rows_processed += 1
             
-            rows_migrated += len(chunk)
-            progress = (rows_migrated / total_rows) * 100 if total_rows > 0 else 100
-            update_status("running", f"Migrated {rows_migrated} of {total_rows} rows.", f"{progress:.2f}%")
+            migration_db.update_migration_job_status(job_id, "RUNNING", migrated_rows=rows_processed)
 
-        update_status("completed", f"Successfully migrated {rows_migrated} rows.", "100%")
-        print(f" [x] Task {task_id} completed successfully.")
+        migration_db.update_migration_job_status(job_id, "COMPLETED", migrated_rows=rows_processed)
+        print(f" [x] Job {job_id}: All {rows_processed} rows published to queue.")
         
         ora_cursor.close()
         ora_conn.close()
+        
+        ch.basic_ack(delivery_tag=method.delivery_tag)
+
+    except Exception as e:
+        error_message = f"Data migration producer task {job_id} failed: {e}"
+        print(f" [!] {error_message}")
+        migration_db.update_migration_job_status(job_id, "FAILED", error_details=error_message)
+        ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)
+
+def data_migration_row_callback(ch, method, properties, body):
+    database.initialize_db_pool()
+    row_message = json.loads(body)
+    job_id = row_message['job_id']
+    row_data = row_message['row_data']
+    column_names = row_message['column_names']
+
+    try:
+        print(f" [x] Received data migration row for job {job_id}")
+        migration_job = migration_db.get_migration_job(job_id)
+        if not migration_job:
+            raise ValueError(f"Migration job {job_id} not found in database.")
+
+        pg_creds_dict = json.loads(migration_job.target_connection_string)
+        pg_conn = psycopg2.connect(
+            dbname=pg_creds_dict['dbname'], user=pg_creds_dict['user'], password=pg_creds_dict['password'],
+            host=pg_creds_dict['host'], port=pg_creds_dict['port']
+        )
+        pg_cursor = pg_conn.cursor()
+
+        dest_table = migration_job.target_table_name
+        
+        # Construct insert query with column names
+        columns_str = ", ".join([f'\"{col}\"' for col in column_names]) # Quote column names to handle special characters
+        placeholders = ", ".join(['%s'] * len(row_data))
+        insert_query = f"INSERT INTO {dest_table} ({columns_str}) VALUES ({placeholders})"
+        
+        pg_cursor.execute(insert_query, row_data)
+        pg_conn.commit()
+        
+        # Assuming the first column is a primary key for tracking purposes
+        source_pk_value = str(row_data[0]) if row_data else None
+        migration_db.log_migration_row_status(job_id, source_pk_value, "MIGRATED")
+        
         pg_cursor.close()
         pg_conn.close()
         
         ch.basic_ack(delivery_tag=method.delivery_tag)
 
     except Exception as e:
-        error_message = f"Data migration task {task_id} failed: {e}"
+        error_message = f"Data migration row task for job {job_id} failed: {e}"
         print(f" [!] {error_message}")
-        update_status("failed", str(e))
+        source_pk_value = str(row_data[0]) if row_data else None
+        migration_db.log_migration_row_status(job_id, source_pk_value, "FAILED", error_message)
         ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)
 
 
@@ -372,54 +402,32 @@ def main():
     channel.basic_qos(prefetch_count=1)
 
     # Setup for SQL Conversion Queue
-    channel.exchange_declare(exchange=SQL_CONVERSION_DLX, exchange_type='fanout')
-    channel.queue_declare(queue=SQL_CONVERSION_DLQ, durable=True, arguments={'x-queue-type': 'quorum'})
-    channel.queue_bind(exchange=SQL_CONVERSION_DLX, queue=SQL_CONVERSION_DLQ)
-    print(f"[*] Dead Letter Queue '{SQL_CONVERSION_DLQ}' is ready.")
-
-    channel.queue_declare(
-        queue=SQL_CONVERSION_QUEUE,
-        durable=True,
-        arguments={
-            'x-queue-type': 'quorum',
-            'x-dead-letter-exchange': SQL_CONVERSION_DLX
-        }
-    )
-    channel.basic_consume(queue=SQL_CONVERSION_QUEUE, on_message_callback=callback)
-    print(f"[*] Listening for messages on '{SQL_CONVERSION_QUEUE}'.")
-
-    # Setup for Data Migration Queue
-    channel.exchange_declare(exchange=DATA_MIGRATION_DLX, exchange_type='fanout')
-    channel.queue_declare(queue=DATA_MIGRATION_DLQ, durable=True, arguments={'x-queue-type': 'quorum'})
-    channel.queue_bind(exchange=DATA_MIGRATION_DLX, queue=DATA_MIGRATION_DLQ)
-    print(f"[*] Dead Letter Queue '{DATA_MIGRATION_DLQ}' is ready.")
-
-    channel.queue_declare(
-        queue=DATA_MIGRATION_QUEUE,
-        durable=True,
-        arguments={
-            'x-queue-type': 'quorum',
-            'x-dead-letter-exchange': DATA_MIGRATION_DLX
-        }
-    )
-    channel.basic_consume(queue=DATA_MIGRATION_QUEUE, on_message_callback=data_migration_callback)
-    print(f"[*] Listening for messages on '{DATA_MIGRATION_QUEUE}'.")
+    sql_conv_config = {
+        'queue': SQL_CONVERSION_QUEUE,
+        'dlx': SQL_CONVERSION_DLX,
+        'dlq': SQL_CONVERSION_DLQ,
+    }
+    queues.declare_quorum_queue(channel, sql_conv_config['queue'], sql_conv_config['dlx'])
+    channel.basic_consume(queue=sql_conv_config['queue'], on_message_callback=callback)
+    print(f"[*] Listening for messages on '{sql_conv_config['queue']}'.")
+
+    # Setup for initial Data Migration Job Queue (producer for row-level jobs)
+    # This queue is where the API sends the initial migration request
+    initial_data_migration_queue_name = 'data_migration_jobs' # Hardcoded for now, as it's not in QUEUE_CONFIG
+    initial_data_migration_dlx = 'data_migration_jobs_dlx'
+    queues.declare_quorum_queue(channel, initial_data_migration_queue_name, initial_data_migration_dlx)
+    channel.basic_consume(queue=initial_data_migration_queue_name, on_message_callback=data_migration_callback)
+    print(f"[*] Listening for messages on '{initial_data_migration_queue_name}'.")
+
+    # Setup for Data Migration Row Queue (consumer for row-level jobs)
+    data_migration_row_config = queues.QUEUE_CONFIG['DATA_MIGRATION_ROW']
+    queues.declare_quorum_queue(channel, data_migration_row_config['queue'], data_migration_row_config['dlx'])
+    channel.basic_consume(queue=data_migration_row_config['queue'], on_message_callback=data_migration_row_callback)
+    print(f"[*] Listening for messages on '{data_migration_row_config['queue']}'.")
 
     # Setup for SQL Execution Queue
     sql_exec_config = queues.QUEUE_CONFIG['SQL_EXECUTION']
-    channel.exchange_declare(exchange=sql_exec_config['dlx'], exchange_type='fanout')
-    channel.queue_declare(queue=sql_exec_config['dlq'], durable=True, arguments={'x-queue-type': 'quorum'})
-    channel.queue_bind(exchange=sql_exec_config['dlx'], queue=sql_exec_config['dlq'])
-    print(f"[*] Dead Letter Queue '{sql_exec_config['dlq']}' is ready.")
-
-    channel.queue_declare(
-        queue=sql_exec_config['queue'],
-        durable=True,
-        arguments={
-            'x-queue-type': 'quorum',
-            'x-dead-letter-exchange': sql_exec_config['dlx']
-        }
-    )
+    queues.declare_quorum_queue(channel, sql_exec_config['queue'], sql_exec_config['dlx'])
     channel.basic_consume(queue=sql_exec_config['queue'], on_message_callback=sql_execution_callback)
     print(f"[*] Listening for messages on '{sql_exec_config['queue']}'.")
 
